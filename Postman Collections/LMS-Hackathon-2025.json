{
	"info": {
		"_postman_id": "bda5396c-789e-40d4-9a86-0398101dc496",
		"name": "LMS-Hackathon-2025",
		"schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
	},
	"item": [
		{
			"name": "UserLogin",
			"item": [
				{
					"name": "User Sign In",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Validate Login Schema\", function () {\r",
									"    var jsonData = pm.response.json();\r",
									"\r",
									"    // Schema for Success (200)\r",
									"    var successSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"token\", \"userId\", \"email\", \"roles\"],\r",
									"        \"properties\": {\r",
									"            \"token\": { \"type\": \"string\" },\r",
									"            \"type\": { \"type\": \"string\" },\r",
									"            \"userId\": { \"type\": \"string\" },\r",
									"            \"email\": { \"type\": \"string\" },\r",
									"            \"roles\": { \"type\": \"array\" },\r",
									"            \"status\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"passwordExpired\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    // Schema for Error (400, 401, 404, 429)\r",
									"    var errorSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    if (pm.response.code === 200) {\r",
									"        pm.response.to.have.jsonSchema(successSchema);\r",
									"    } else {\r",
									"        pm.response.to.have.jsonSchema(errorSchema);\r",
									"    }\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/login",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"login"
							]
						}
					},
					"response": []
				},
				{
					"name": "Forgot Password Confirm Email",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Validate Confirm Email Schema\", function () {\r",
									"    var jsonData = pm.response.json();\r",
									"\r",
									"    var successSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"token\", \"userId\", \"email\"], // Adjusted based on your snippet\r",
									"        \"properties\": {\r",
									"            \"token\": { \"type\": \"string\" },\r",
									"            \"type\": { \"type\": \"string\" },\r",
									"            \"userId\": { \"type\": \"string\" },\r",
									"            \"email\": { \"type\": \"string\" },\r",
									"            \"roles\": { \"type\": \"array\" },\r",
									"            \"status\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"passwordExpired\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    var errorSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    if (pm.response.code === 200) {\r",
									"        pm.response.to.have.jsonSchema(successSchema);\r",
									"    } else {\r",
									"        pm.response.to.have.jsonSchema(errorSchema);\r",
									"    }\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/login/forgotpassword/confirmEmail",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"login",
								"forgotpassword",
								"confirmEmail"
							]
						}
					},
					"response": []
				},
				{
					"name": "Reset Password",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Validate Reset Password Schema\", function () {\r",
									"    var jsonData = pm.response.json();\r",
									"\r",
									"    // We enforce the 'Success Schema' (Token/User Object)\r",
									"    // If the API returns {\"message\": \"saved\"}, this schema check will FAIL.\r",
									"    var successSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"token\", \"userId\", \"email\"], \r",
									"        \"properties\": {\r",
									"            \"token\": { \"type\": \"string\" },\r",
									"            \"type\": { \"type\": \"string\" },\r",
									"            \"userId\": { \"type\": \"string\" },\r",
									"            \"email\": { \"type\": \"string\" },\r",
									"            \"roles\": { \"type\": \"array\" },\r",
									"            \"status\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"passwordExpired\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    var errorSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"\r",
									"    if (pm.response.code === 200) {\r",
									"        pm.response.to.have.jsonSchema(successSchema);\r",
									"    } else {\r",
									"        pm.response.to.have.jsonSchema(errorSchema);\r",
									"    }\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/resetPassword",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"resetPassword"
							]
						}
					},
					"response": []
				},
				{
					"name": "User Logout",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Validate Content-Type\", function () {\r",
									"    var ct = pm.response.headers.get(\"Content-Type\");\r",
									"    \r",
									"    if (pm.response.code === 200) {\r",
									"        // Success Case: Expect Plain Text\r",
									"        pm.expect(ct).to.include(\"text\"); \r",
									"    } else {\r",
									"        // Failure Case: Expect JSON\r",
									"        pm.expect(ct).to.include(\"application/json\");\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Validate Logout Schema\", function () {\r",
									"    // 1. Success Case (Plain Text)\r",
									"    if (pm.response.code === 200) {\r",
									"         pm.expect(pm.response.text()).to.include(\"Logout successful\");\r",
									"    } \r",
									"    // 2. Failure Case (JSON Error)\r",
									"    else {\r",
									"         var errorSchema = {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"message\": { \"type\": \"string\" },\r",
									"                \"success\": { \"type\": \"boolean\" }\r",
									"            }\r",
									"        };\r",
									"        pm.response.to.have.jsonSchema(errorSchema);\r",
									"    }\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/logoutlms",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"logoutlms"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// 1. TRAFFIC COP\r",
							"var targetRequest = pm.iterationData.get(\"Request Name\");\r",
							"var currentRequest = pm.info.requestName;\r",
							"if (targetRequest && targetRequest !== currentRequest) {\r",
							"    pm.execution.skipRequest();\r",
							"    return;\r",
							"}\r",
							"\r",
							"// ==================================================\r",
							"// 2. METHOD OVERRIDE\r",
							"// ==================================================\r",
							"// This checks if the CSV has a \"Request Method\" value for this row.\r",
							"// If yes, it forces the request to use that method (e.g., forcing GET to be POST).\r",
							"var methodOverride = pm.iterationData.get(\"Request Method\");\r",
							"\r",
							"if (methodOverride) {\r",
							"    pm.request.method = methodOverride;\r",
							"    console.log(\"Overriding Method to: \" + methodOverride);\r",
							"}\r",
							"\r",
							"\r",
							"var csvPayload = pm.iterationData.get(\"Payload\");\r",
							"if (csvPayload) {\r",
							"    if (typeof csvPayload === 'object') {\r",
							"        // It's a JSON object (from JSON file) -> Stringify it for the Body\r",
							"        pm.collectionVariables.set(\"Payload\", JSON.stringify(csvPayload));\r",
							"    } else {\r",
							"        // It's a String (from CSV) -> Try to parse/clean it\r",
							"        try {\r",
							"            var obj = JSON.parse(csvPayload);\r",
							"            pm.collectionVariables.set(\"Payload\", JSON.stringify(obj));\r",
							"        } catch (e) {\r",
							"            pm.collectionVariables.set(\"Payload\", csvPayload);\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"// ==================================================\r",
							"// TOKEN OVERRIDE LOGIC\r",
							"// ==================================================\r",
							"var tokenAction = pm.iterationData.get(\"TokenOverride\");\r",
							"\r",
							"if (tokenAction === \"remove\") {\r",
							"    pm.request.auth.type = \"noauth\"; \r",
							"    \r",
							"    // 2. Double check to remove any manual headers if they exist\r",
							"    pm.request.headers.remove(\"Authorization\");\r",
							"    \r",
							"    console.log(\"Token REMOVED for this request (Scenario: \" + pm.iterationData.get(\"Scenario Id\") + \")\");\r",
							"} \r",
							"else if (tokenAction === \"invalid\") {\r",
							"    pm.request.auth.use(\"bearer\", {\r",
							"        token: \"INVALID_GARBAGE_TOKEN_123\"\r",
							"    });\r",
							"    console.log(\"Injected INVALID Token\");\r",
							"}\r",
							"else if (tokenAction === \"expired_token\") {\r",
							"     pm.request.auth.use(\"bearer\", {\r",
							"        token: \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjQ1NTI4NDcsImV4cCI6MTc2NDU4MTY0N30.W7Hywl19--Vce0vfuqvpgoEVQCQRUnexmyAejUM04unnWZNyJ8ucz1RzOtSKJ6WZ1AV1BogIPnKGzLuPa4VrsQ\"\r",
							"    });\r",
							"}\r",
							"\r",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// ==================================================\r",
							"// 1. SKIP SAFETY (Exit if no response)\r",
							"// ==================================================\r",
							"if (!pm.response.code) return;\r",
							"\r",
							"\r",
							"\r",
							"// ==================================================\r",
							"// 2. STATUS CHECK & METHOD NOT ALLOWED\r",
							"// ==================================================\r",
							"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
							"\r",
							"\r",
							"if (expectedStatus) {\r",
							"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
							"        pm.response.to.have.status(expectedStatus);\r",
							"    });\r",
							"\r",
							"\r",
							"    // SPECIAL CHECK: Method Not Allowed (405)\r",
							"    if (expectedStatus === 405) {\r",
							"        pm.test(\"Verify Method Not Allowed Error\", function () {\r",
							"            if (pm.response.text()) {\r",
							"                var jsonData = pm.response.json();\r",
							"                var msg = jsonData.message || jsonData.error || \"\"; \r",
							"                pm.expect(msg).to.include(\"not supported\");\r",
							"            } else {\r",
							"                console.warn(\"405 returned with empty body\");\r",
							"            }\r",
							"        });\r",
							"    }\r",
							"}\r",
							"\r",
							"\r",
							"\r",
							"// ==================================================\r",
							"// 3. CONTENT-TYPE CHECK\r",
							"// ==================================================\r",
							"// Only run this if it is NOT the Logout request\r",
							"if (!pm.info.requestName.includes(\"User Logout\")) {\r",
							"    pm.test(\"Content-Type is application/json\", function () {\r",
							"        if (pm.response.code !== 204) {\r",
							"            var ct = pm.response.headers.get(\"Content-Type\");\r",
							"            pm.expect(ct, \"Content-Type Header is MISSING\").to.exist; \r",
							"            pm.expect(ct).to.include(\"application/json\");\r",
							"        }\r",
							"    });\r",
							"}\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"// ==================================================\r",
							"// 4. UNIVERSAL CAPTURE (Save Token Only)\r",
							"// ==================================================\r",
							"if (pm.response.code === 200) {\r",
							"    try {\r",
							"        var jsonData = pm.response.json();\r",
							"        \r",
							"        // CAPTURE TOKEN (Critical for other requests)\r",
							"        if (jsonData.token) {\r",
							"            pm.collectionVariables.set(\"token\", jsonData.token);\r",
							"            console.log(\"Refreshed Bearer Token from Login\");\r",
							"        }\r",
							"\r",
							"\r",
							"    } catch (e) { console.warn(\"Failed to parse capture data\"); }\r",
							"}\r",
							"\r",
							"\r",
							"\r",
							"// ==================================================\r",
							"// 5. RESPONSE MESSAGE VALIDATION\r",
							"// ==================================================\r",
							"pm.test(\"Response body message matches contract\", function () {\r",
							"    var expectedBodyString = pm.iterationData.get(\"Expected Response Body\");\r",
							"    \r",
							"    if (expectedBodyString) {\r",
							"        // 1. FAIL if we expected a body but got EMPTY\r",
							"        if (!pm.response.text()) {\r",
							"            pm.expect.fail(\"Expected JSON body '\" + expectedBodyString + \"' but got EMPTY response.\");\r",
							"            return;\r",
							"        }\r",
							"\r",
							"\r",
							"        try {\r",
							"            // FIX: Remove newlines/tabs that might break JSON parsing\r",
							"            var cleanString = expectedBodyString.replace(/(\\r\\n|\\n|\\r)/gm, \" \").trim();\r",
							"            \r",
							"            var expectedJson = JSON.parse(cleanString);\r",
							"            var actualJson = pm.response.json();\r",
							"            \r",
							"            // If the expected data has a 'message', verify it matches the actual response\r",
							"            if (expectedJson.message) {\r",
							"                pm.expect(actualJson.message, \"Error Message Mismatch\").to.eql(expectedJson.message); \r",
							"            }\r",
							"        } catch (e) {\r",
							"            console.log(\"JSON Parse Error: \" + e.message);\r",
							"            pm.expect.fail(\"Test Failed: CSV 'Expected Response Body' is not valid JSON. Data: \" + expectedBodyString);\r",
							"        }\r",
							"    }\r",
							"});"
						]
					}
				}
			]
		},
		{
			"name": "UserController",
			"item": [
				{
					"name": "Create User Login with Role",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "f854d671-a716-4003-b6ec-59ed04a2ec18",
								"exec": [
									" //parse json\r",
									" const res = pm.response.json();\r",
									"\r",
									"//Dynamic status code validation\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"// validates response message only  when run status = 201\r",
									"if (pm.response.code === 201) {\r",
									"\r",
									"   console.log(\"User Created Successfully\");\r",
									"   console.log(res);\r",
									"\r",
									"    pm.test(\"Status code name has string\", function () {\r",
									"    pm.response.to.have.status(\"Created\");\r",
									"    });\r",
									"   \r",
									"\r",
									"    //Validate mandatory fields and its types in user object\r",
									"    pm.test(\"User mandatory fields exist\", function () {\r",
									"        pm.expect(res.user).to.have.property(\"userFirstName\").that.is.a(\"string\");\r",
									"        pm.expect(res.user).to.have.property(\"userLastName\").that.is.a(\"string\");\r",
									"        pm.expect(res.user).to.have.property(\"userLocation\").that.is.a(\"string\");\r",
									"        pm.expect(res.user).to.have.property(\"userTimeZone\").that.is.a(\"string\");\r",
									"        pm.expect(res.user).to.have.property(\"userVisaStatus\").that.is.a(\"string\");\r",
									"        pm.expect(res.user).to.have.property(\"userLoginEmail\").that.is.a(\"string\");\r",
									"    });\r",
									"\r",
									"    //Validate mandatory fields and its types in roles array\r",
									"    pm.test(\"Role mandatory fields exist\", function () {\r",
									"        pm.expect(res.roles).to.be.an(\"array\").that.is.not.empty;\r",
									"        pm.expect(res.roles[0]).to.have.property(\"roleId\").that.is.a(\"string\");\r",
									"        pm.expect(res.roles[0]).to.have.property(\"userRoleStatus\").that.is.a(\"string\");\r",
									"    });\r",
									"\r",
									"    // ----- Save userId  for chaining-----\r",
									"    if (res.user && res.user.userId) {\r",
									"        pm.collectionVariables.set(\"userId\", res.user.userId);\r",
									"        console.log(\"Saved userId:\", res.user.userId);\r",
									"    } else {\r",
									"        console.log(\"userId not found in response\");\r",
									"    }\r",
									"\r",
									"    // ----- Save roleId (roles is an array) -----\r",
									"    if (res.roles && Array.isArray(res.roles) && res.roles.length > 0) {\r",
									"        pm.collectionVariables.set(\"roleId\", res.roles[0].roleId);\r",
									"        console.log(\"Saved roleId:\", res.roles[0].roleId);\r",
									"    } else {\r",
									"        console.log(\"roleId not found in response\");\r",
									"    }\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"//schema validation \r",
									"const schema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"user\": {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"userId\": { \"type\": \"string\" },\r",
									"                \"userFirstName\": { \"type\": \"string\" },\r",
									"                \"userLastName\": { \"type\": \"string\" },\r",
									"                \"userMiddleName\": { \"type\": \"string\" },\r",
									"                \"userPhoneNumber\": { \"type\": \"string\" },\r",
									"                \"userLocation\": { \"type\": \"string\" },\r",
									"                \"userTimeZone\": { \"type\": \"string\" },\r",
									"                \"userLinkedinUrl\": { \"type\": \"string\" },\r",
									"                \"userEduUg\": { \"type\": \"string\" },\r",
									"                \"userEduPg\": { \"type\": \"string\" },\r",
									"                \"userComments\": { \"type\": \"string\" },\r",
									"                \"userVisaStatus\": { \"type\": \"string\" },\r",
									"                \"userLoginEmail\": { \"type\": \"string\" }\r",
									"            },\r",
									"            \"required\": [\"userFirstName\", \"userLastName\", \"userPhoneNumber\", \"userLoginEmail\",\r",
									"            \"userLocation\",\"userTimeZone\",\"userVisaStatus\"]\r",
									"        },\r",
									"        \"roles\": {\r",
									"            \"type\": \"array\",\r",
									"            \"items\": {\r",
									"                \"type\": \"object\",\r",
									"                \"properties\": {\r",
									"                    \"roleId\": { \"type\": \"string\" },\r",
									"                    \"userRoleStatus\": { \"type\": \"string\" }\r",
									"                },\r",
									"                \"required\": [\"roleId\", \"userRoleStatus\"]\r",
									"            }\r",
									"        },\r",
									"        \"programBatches\": { \"type\": \"array\" },\r",
									"        \"skills\": { \"type\": \"array\" },\r",
									"        \"documents\": { \"type\": \"array\" }\r",
									"    },\r",
									"    \"required\": [\"user\", \"roles\"]\r",
									"};\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "9cfb4b0e-5ac8-45a1-93be-b9460201032e",
								"exec": [
									"\r",
									"//1. Get the nested objects from the Data File\r",
									"var loginData = pm.iterationData.get(\"userLogin\");\r",
									"var roleMaps = pm.iterationData.get(\"userRoleMaps\");\r",
									"\r",
									"\r",
									"// 2. Map 'userLogin' fields to variables\r",
									"if (loginData) {\r",
									"    // pm.variables.set(\"userLoginEmail\", loginData.userLoginEmail);\r",
									"    pm.variables.set(\"loginStatus\", loginData.loginStatus);\r",
									"    pm.variables.set(\"status\", loginData.status);\r",
									"}\r",
									"\r",
									"// 3. Map 'userRoleMaps' fields (taking the first item in the array)\r",
									"if (roleMaps && roleMaps.length > 0) {\r",
									"    pm.variables.set(\"roleId\", roleMaps[0].roleId);\r",
									"    pm.variables.set(\"userRoleStatus\", roleMaps[0].userRoleStatus);\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "2e7e7ec1-d451-49eb-b4fb-1dba6ebd2097",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/roleStatus"
					},
					"response": []
				},
				{
					"name": "User information by Id",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "2d276953-309c-463c-8775-d3437b4d92c7",
								"exec": [
									"//Dynamic status code validation\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"// Parse response\r",
									"//let res = pm.response.json();\r",
									"\r",
									"// Parse Response\r",
									"// ---------------------------\r",
									"let res;\r",
									"try {\r",
									"    res = pm.response.json();\r",
									"} catch (e) {\r",
									"    // No JSON body\r",
									"    res = {};\r",
									"}\r",
									"\r",
									"// -----------------------------------------\r",
									"// 1. Validate USER object\r",
									"// -----------------------------------------\r",
									"//let user = res.user;\r",
									"\r",
									"// 3. Run positive validations ONLY when status = 200\r",
									"// ---------------------------\r",
									"if (pm.response.code === 200) {\r",
									"\r",
									"pm.test(\"Validate all required user fields\", function () {\r",
									"    const expectedUserFields = [\r",
									"        \"userId\",\r",
									"        \"userFirstName\",\r",
									"        \"userLastName\",\r",
									"        \"userMiddleName\",\r",
									"        \"userPhoneNumber\",\r",
									"        \"userLocation\",\r",
									"        \"userTimeZone\",\r",
									"        \"userLinkedinUrl\",\r",
									"        \"userEduUg\",\r",
									"        \"userEduPg\",\r",
									"        \"userComments\",\r",
									"        \"userVisaStatus\",\r",
									"        \"userLoginEmail\"\r",
									"    ];\r",
									"\r",
									"    expectedUserFields.forEach(field => {\r",
									"        pm.expect(user, `Missing field: ${field}`).to.have.property(field);\r",
									"    });\r",
									"});\r",
									"\r",
									"// -----------------------------------------\r",
									"// 2. Validate ROLES array\r",
									"// -----------------------------------------\r",
									"let roles = res.roles;\r",
									"\r",
									"pm.test(\"Roles should be an array\", function () {\r",
									"    pm.expect(roles).to.be.an(\"array\");\r",
									"    pm.expect(roles.length).to.be.above(0);\r",
									"});\r",
									"\r",
									"// -----------------------------------------\r",
									"// 3. Validate each ROLE object\r",
									"// -----------------------------------------\r",
									"pm.test(\"Validate required role fields for each role\", function () {\r",
									"    roles.forEach(role => {\r",
									"        pm.expect(role).to.have.property(\"roleId\");\r",
									"        pm.expect(role).to.have.property(\"userRoleStatus\");\r",
									"\r",
									"        pm.expect(role.roleId).to.be.a(\"string\");\r",
									"        pm.expect(role.userRoleStatus).to.be.a(\"string\");\r",
									"    });\r",
									"});\r",
									"\r",
									"}\r",
									"\r",
									"// ==================================================\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    // 1. Safety Check: If body is empty, skip schema validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; // Stop the test here\r",
									"    }\r",
									"\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName; \r",
									"\r",
									"    // --- DEFINITIONS ---\r",
									"    var userObjectSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"userId\",\"userFirstName\",\"userLastName\",\r",
									"        \"userMiddleName\",\r",
									"        \"userPhoneNumber\",\r",
									"        \"userLocation\",\r",
									"        \"userTimeZone\",\r",
									"        \"userLinkedinUrl\",\r",
									"        \"userEduUg\",\r",
									"        \"userEduPg\",\r",
									"        \"userComments\",\r",
									"        \"userVisaStatus\",\r",
									"        \"userLoginEmail\"\r",
									"        ],\r",
									"        \"properties\": {\r",
									"            \"userId\": { \"type\": \"integer\" },\r",
									"            \"userFirstName\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLocation\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userTimeZone\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLinkedinUrl\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userEduUg\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userEduPg\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userComments\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userVisaStatus\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLoginEmail\": { \"type\": [\"string\", \"null\"] }\r",
									"        }\r",
									"        \r",
									"    };\r",
									"\r",
									"    var listSchema = {\r",
									"        \"type\": \"array\",\r",
									"        \"items\": userObjectSchema\r",
									"    };\r",
									"\r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"           }\r",
									"    };\r",
									"\r",
									"    // --- LOGIC ---\r",
									"\r",
									"    // CASE A: Endpoints that return ARRAYS\r",
									"    if (requestName === \"User information by Id\") {\r",
									"        if (pm.response.code === 200) {\r",
									"             pm.response.to.have.jsonSchema(listSchema);\r",
									"        } else {\r",
									"             pm.response.to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    }\r",
									"        \r",
									"});\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "4897b500-be54-46c1-abf9-09b52c05f7de",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "99bef5eb-8828-4787-b8c2-0781ae958f4c",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/users/{{userId}}"
					},
					"response": []
				},
				{
					"name": "Delete User",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "95a6a4f9-a7f1-4eef-83fe-7a5d924eb9ed",
								"exec": [
									"\r",
									"\r",
									"//Dynamic status code validation\r",
									"let expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"pm.test(\"Status code matches expected\", function() {\r",
									"    pm.expect(pm.response.code).to.eql(expectedStatus);\r",
									"});\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"//schema validation \r",
									"const schema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"user\": {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"                \"userId\": { \"type\": \"string\" },\r",
									"                \"userFirstName\": { \"type\": \"string\" },\r",
									"                \"userLastName\": { \"type\": \"string\" },\r",
									"                \"userMiddleName\": { \"type\": \"string\" },\r",
									"                \"userPhoneNumber\": { \"type\": \"string\" },\r",
									"                \"userLocation\": { \"type\": \"string\" },\r",
									"                \"userTimeZone\": { \"type\": \"string\" },\r",
									"                \"userLinkedinUrl\": { \"type\": \"string\" },\r",
									"                \"userEduUg\": { \"type\": \"string\" },\r",
									"                \"userEduPg\": { \"type\": \"string\" },\r",
									"                \"userComments\": { \"type\": \"string\" },\r",
									"                \"userVisaStatus\": { \"type\": \"string\" },\r",
									"                \"userLoginEmail\": { \"type\": \"string\" }\r",
									"            },\r",
									"            \"required\": [\"userFirstName\", \"userLastName\", \"userPhoneNumber\", \"userLoginEmail\",\r",
									"            \"userLocation\",\"userTimeZone\",\"userVisaStatus\"]\r",
									"        },\r",
									"        \"roles\": {\r",
									"            \"type\": \"array\",\r",
									"            \"items\": {\r",
									"                \"type\": \"object\",\r",
									"                \"properties\": {\r",
									"                    \"roleId\": { \"type\": \"string\" },\r",
									"                    \"userRoleStatus\": { \"type\": \"string\" }\r",
									"                },\r",
									"                \"required\": [\"roleId\", \"userRoleStatus\"]\r",
									"            }\r",
									"        },\r",
									"        \"programBatches\": { \"type\": \"array\" },\r",
									"        \"skills\": { \"type\": \"array\" },\r",
									"        \"documents\": { \"type\": \"array\" }\r",
									"    },\r",
									"    \"required\": [\"user\", \"roles\"]\r",
									"};\r",
									"\r",
									"pm.test(\"Content-Type is application/json\", function () {\r",
									"    if (pm.response.headers.has(\"Content-Type\")) {\r",
									"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/plain\");\r",
									"    } else {\r",
									"        console.warn(\"Content-Type header missing. Skipping check.\");\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "c10c2c09-b2dd-4a39-911b-b4f02e85fe22",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "f2e14d2c-2b59-44ef-8b9c-74bec8cf78d2",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "DELETE",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/{{userId}}"
					},
					"response": []
				},
				{
					"name": "Update UserLogin status",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "cf12a508-3816-44dd-b2e7-d6109a08d998",
								"exec": [
									"//Dynamic status code validation\r",
									"let expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"pm.test(\"Status code matches expected\", function() {\r",
									"    pm.expect(pm.response.code).to.eql(expectedStatus);\r",
									"});\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    // 1. Safety Check: If body is empty, skip schema validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; // Stop the test here\r",
									"    }\r",
									"\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName; \r",
									"\r",
									"    // --- DEFINITIONS ---\r",
									"    var loginStatusSchema = {\r",
									"        \"type\": \"string\",\r",
									"         \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" }\r",
									"         }\r",
									"        };\r",
									"      \r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"             }\r",
									"    };\r",
									"\r",
									"    // --- LOGIC ---\r",
									"\r",
									"    // CASE A: Endpoints that return ARRAYS\r",
									"    if (requestName === \"Update UserLogin status\") {\r",
									"         if ((pm.response.code === 200) && jsonData.userId !== undefined) {\r",
									"            pm.response.to.have.jsonSchema(loginStatusSchema);\r",
									"        } \r",
									"        // Otherwise -> Message Object (covers Errors and DELETE success messages)\r",
									"        else {\r",
									"            pm.response.to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    }\r",
									"        \r",
									"});\r",
									"\r",
									"pm.test(\"Content-Type is application/json\", function () {\r",
									"    if (pm.response.headers.has(\"Content-Type\")) {\r",
									"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/plain\");\r",
									"    } else {\r",
									"        console.warn(\"Content-Type header missing. Skipping check.\");\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "493821f7-73b1-4f74-92f4-5628586fa18b",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "592b43aa-c503-4516-88c1-f161f1c6ce0c",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/userLogin/{{userId}}"
					},
					"response": []
				},
				{
					"name": "Update User",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "a0b184da-8cc1-4964-99ac-c9ded7973bc3",
								"exec": [
									"//Dynamic status code validation\r",
									"let expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"pm.test(\"Status code matches expected\", function() {\r",
									"    pm.expect(pm.response.code).to.eql(expectedStatus);\r",
									"});\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    // 1. Safety Check: If body is empty, skip schema validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; // Stop the test here\r",
									"    }\r",
									"\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName; \r",
									"\r",
									"    // --- DEFINITIONS ---\r",
									"    var updateUserSchema = {\r",
									"        \"type\": \"string\",\r",
									"         \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" }\r",
									"         }\r",
									"        };\r",
									"      \r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"             }\r",
									"    };\r",
									"\r",
									"    // --- LOGIC ---\r",
									"\r",
									"    // CASE A: Endpoints that return ARRAYS\r",
									"    if (requestName === \"Update User\") {\r",
									"         if ((pm.response.code === 200) && jsonData.userId !== undefined) {\r",
									"            pm.response.to.have.jsonSchema(updateUserSchema);\r",
									"        } \r",
									"        // Otherwise -> Message Object (covers Errors and DELETE success messages)\r",
									"        else {\r",
									"            pm.response.to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    }\r",
									"        \r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "4bc213c9-ddaa-4834-a413-5f6488ebb219",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "e818299c-22c8-467f-b744-55af07ce3ec3",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/{{userId}}"
					},
					"response": []
				},
				{
					"name": "all users",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "49ee3aad-bde7-4152-8a37-593fc9b57cfb",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									"\r",
									"// var overrideStatus = pm.iterationData.get(\"Token Override\");\r",
									"\r",
									"// if (overrideStatus === \"invalid\") {\r",
									"//     // Use 'pm.request.auth.bearer' to directly modify the Auth Helper\r",
									"//     // This is the most direct way to tell the Auth Tab \"Use THIS token, not the variable\"\r",
									"//     pm.request.auth.use(\"bearer\", {\r",
									"//         token: \"INVALID_TOKEN_12345\"\r",
									"//     });\r",
									"    \r",
									"//     console.log(\"Updated Auth Tab directly with INVALID token\");\r",
									"// }"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "84d2429c-606c-4155-9cb5-4475b7920338",
								"exec": [
									"\r",
									"//Dynamic status code validation\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"// Parse response\r",
									"//let res = pm.response.json();\r",
									"\r",
									"// Parse Response\r",
									"// ---------------------------\r",
									"let res;\r",
									"try {\r",
									"    res = pm.response.json();\r",
									"} catch (e) {\r",
									"    // No JSON body\r",
									"    res = {};\r",
									"}\r",
									"\r",
									"\r",
									"// ==================================================\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    // 1. Safety Check: If body is empty, skip schema validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; // Stop the test here\r",
									"    }\r",
									"\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName; \r",
									"\r",
									"    // --- DEFINITIONS ---\r",
									"    var alluserObjectSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"userId\",\"userFirstName\",\"userLastName\",\r",
									"        \"userPhoneNumber\",\r",
									"        \"userLocation\",\r",
									"        \"userTimeZone\",\r",
									"        \"userLinkedinUrl\",\r",
									"        \"userEduUg\",\r",
									"        \"userEduPg\",\r",
									"        \"userVisaStatus\",\r",
									"        \"userLoginEmail\"\r",
									"        ],\r",
									"        \"properties\": {\r",
									"            \"userId\": { \"type\": \"string\" },\r",
									"            \"userFirstName\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLastName\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userMiddleName\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userPhoneNumber\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLocation\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userTimeZone\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLinkedinUrl\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userEduUg\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userEduPg\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userComments\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userVisaStatus\": { \"type\": [\"string\", \"null\"] },\r",
									"            \"userLoginEmail\": { \"type\": [\"string\", \"null\"] }\r",
									"        }\r",
									"        \r",
									"    };\r",
									"\r",
									"    var listSchema = {\r",
									"        \"type\": \"array\",\r",
									"        \"items\": alluserObjectSchema\r",
									"    };\r",
									"\r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"           }\r",
									"    };\r",
									"\r",
									"    // --- LOGIC ---\r",
									"\r",
									"    // CASE A: Endpoints that return ARRAYS\r",
									"    //if (requestName === \"all users\") {\r",
									"        if (pm.response.code === 200) {\r",
									"             pm.response.to.have.jsonSchema(listSchema);\r",
									"        } else {\r",
									"             pm.response.to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    \r",
									"        \r",
									"});\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "901b3833-2c01-4310-a86a-ebcf9a2ed2b5",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/users"
					},
					"response": []
				},
				{
					"name": "all users with facets",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "95c4576b-f2e4-4aa4-9053-480d6f2c6e25",
								"exec": [
									"//Dynamic status code validation\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "6b655970-237c-4373-94d9-6ebe351516b8",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "12c3ecc1-9791-4688-a3ef-59af54d1c061",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/v2/users"
					},
					"response": []
				},
				{
					"name": "update userRole program batch status",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "dcc398b6-1060-4c24-b551-6a475e7411c6",
								"exec": [
									"//Dynamic status code validation\r",
									"let expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"pm.test(\"Status code matches expected\", function() {\r",
									"    pm.expect(pm.response.code).to.eql(expectedStatus);\r",
									"});\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    // 1. Safety Check: If body is empty, skip schema validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; // Stop the test here\r",
									"    }\r",
									"\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName; \r",
									"\r",
									"    // --- DEFINITIONS ---\r",
									"    var updateroleIdSchema = {\r",
									"        \"type\": \"string\",\r",
									"         \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" }\r",
									"         }\r",
									"        };\r",
									"      \r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"             }\r",
									"    };\r",
									"\r",
									"    // --- LOGIC ---\r",
									"\r",
									"    // CASE A: Endpoints that return ARRAYS\r",
									"    if (requestName === \"Update User role Id\") {\r",
									"         if ((pm.response.code === 200) && jsonData.userId !== undefined) {\r",
									"            pm.response.to.have.jsonSchema(updateroleIdSchema);\r",
									"        } \r",
									"        // Otherwise -> Message Object (covers Errors and DELETE success messages)\r",
									"        else {\r",
									"            pm.response.to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    }\r",
									"        \r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "da1eb592-cee3-4cb5-92ee-96054c6622b6",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "3508c5ab-a64e-44da-b513-08e732959615",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/roleProgramBatchStatus/{{userId}}"
					},
					"response": []
				},
				{
					"name": "Update User role Id",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "71eb1de8-9331-4a22-b087-0a6d6ad26d8b",
								"exec": [
									"//Dynamic status code validation\r",
									"let expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"pm.test(\"Status code matches expected\", function() {\r",
									"    pm.expect(pm.response.code).to.eql(expectedStatus);\r",
									"});\r",
									"\r",
									"//Dynamic status response\r",
									"let expectedMessage = pm.iterationData.get(\"Expected Response Body\");\r",
									"if (expectedMessage) {\r",
									"    pm.test(\"Response message matches expected\", function() {\r",
									"        let res = pm.response.json();\r",
									"        pm.expect(res.message || res.status).to.include(expectedMessage);\r",
									"    });\r",
									"}\r",
									"\r",
									"// 5. SCHEMA VALIDATION (Complete & Safe)\r",
									"// ==================================================\r",
									"pm.test(\"Validate Response Schema\", function () {\r",
									"    var requestName = pm.info.requestName;\r",
									"    // --- DEFINITIONS ---\r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"message\", \"success\"],\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"        }\r",
									"    };\r",
									"    if (requestName === \"Update User role Id\") {\r",
									"        // CASE 1: Positive Scenario (200 OK + String Body)\r",
									"        if (pm.response.code === 200) {\r",
									"            // Since it's a plain string, we validate the TEXT, not JSON\r",
									"            pm.expect(pm.response.text()).to.be.a('string');\r",
									"        }\r",
									"        // CASE 2: Negative Scenario (400/404/500 + JSON Object)\r",
									"        else {\r",
									"            // We only parse JSON here, because we know it's an object\r",
									"            var jsonData = pm.response.json();\r",
									"            pm.expect(jsonData).to.have.jsonSchema(messageSchema);\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Content-Type is application/json\", function () {\r",
									"    if (pm.response.headers.has(\"Content-Type\")) {\r",
									"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"text/plain\");\r",
									"    } else {\r",
									"        console.warn(\"Content-Type header missing. Skipping check.\");\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "f702efb5-ed05-45ef-92bb-5c4d6ad5504e",
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\"); // e.g., \"/users/roleStatus/{{roleId}}\"\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"\r",
									"    // 3. Handle dynamic variable replacement\r",
									"    // Example: replace {{roleId}} if present in CSV endpoint\r",
									"    let currentRoleId = pm.collectionVariables.get(\"roleId\");\r",
									"    if (currentRoleId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{roleId}}\", currentRoleId);\r",
									"    }\r",
									"\r",
									"    // Optional: if you want to replace other placeholders\r",
									"    let currentUserId = pm.collectionVariables.get(\"userId\");\r",
									"    if (currentUserId) {\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{userId}}\", currentUserId);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    let baseUrl = pm.collectionVariables.get(\"baseUrl\"); // Make sure baseUrl is defined in collection variables\r",
									"    let newUrl = baseUrl + csvEndpoint;\r",
									"\r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl);\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "9ff01ad7-0db8-4e27-84b4-44a8d39832fc",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/users/roleId/{{userId}}"
					},
					"response": []
				},
				{
					"name": "Get User BatchId by User Id",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "ba38f340-5d6e-46d9-ad1d-07d594781c93",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"pm.test(\"Test response to have all expected values\", function () {",
									"    const response = pm.response.json();",
									"    console.log(response); // Log the response for debugging purposes",
									"    const batchId = pm.collectionVariables.get(\"batchId\"); // Assuming batchId is a collection variable",
									"    console.log(batchId);",
									"        const batchIdInt = parseInt(batchId, 10);",
									"    pm.expect(response).to.eql(batchIdInt);",
									"",
									"}); "
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "50f871ad-da9a-435c-86f7-38047d0bc031",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "c07d624b-3cc3-47cf-88df-5bf9f6ac30d3",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/user/{{userId}}",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/user/01' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get User Roles",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "965f5a58-18fe-482d-a6a0-2d66374d8e28",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"const response = pm.response.json();",
									"console.log(response);",
									"",
									"pm.test(\"Response has all expected fields\", function () {",
									"",
									"    pm.expect(response).to.have.keys([",
									"        \"userRoleId\",",
									"        \"usedId\",",
									"        \"userFirstName\",",
									"        \"userLastName\",",
									"        \"userMiddleName\",",
									"        \"userPhoneNumber\",",
									"        \"userLocation\",",
									"        \"userTimeZone\",",
									"        \"userLinkedinUrl\",",
									"        \"userEduUg\",",
									"        \"userComments\",",
									"        \"userVisaStatus\",",
									"        \"roleId\",",
									"        \"roleName\",",
									"        \"roleDesc\",",
									"        \"creationTime\",",
									"        \"lastModTime\",",
									"        \"userRoleStatus\"",
									"",
									"    ]);",
									"",
									"",
									"",
									"});",
									"",
									"pm.test(\"Response has all fields with expected DataType\", function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response.userRoleId).to.be.a('number');",
									"    pm.expect(response.userId).to.be.a('string');",
									"    pm.expect(response.userFirstName).to.be.a('string');",
									"    pm.expect(response.userLastName).to.be.a('string');",
									"    pm.expect(response.userMiddleName).to.be.a('string');",
									"    pm.expect(response.userPhoneNumber).to.be.a('string');",
									"    pm.expect(response.userLocation).to.be.a('string');",
									"    pm.expect(response.userTimeZone).to.be.a('string');",
									"    pm.expect(response.userLinkedinUrl).to.be.a('string');",
									"    pm.expect(response.userEduUg).to.be.a('string');",
									"    pm.expect(response.userComments).to.be.a('string');",
									"    pm.expect(response.userVisaStatus).to.be.a('string');",
									"    pm.expect(response.roleId).to.be.a('string');",
									"    pm.expect(response.roleName).to.be.a('string');",
									"    pm.expect(response.roleDesc).to.be.a('string');",
									"    pm.expect(response.userRoleStatus).to.be.a('string');",
									"",
									"});",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "103a418f-7e30-4b6e-bd6d-b18b31eb40e3",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "f8954f63-18fc-4225-98b5-3093e6a5b90d",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/roles",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/roles' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get User By RoleID",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "d4ac498a-fcfe-4374-a306-d11c4a0af3d4",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"pm.test(\"Each object in array: present fields are strings or null\", function () {",
									"    const response = pm.response.json();",
									"    ",
									"    // Fields that are expected to be present, and their value must be string or null",
									"    const expectedFields = [",
									"        \"userComments\",",
									"        \"userEduPg\",",
									"        \"userEduUg\",",
									"        \"userFirstName\",",
									"        \"userId\",",
									"        \"userLastName\",",
									"        \"userLinkedinUrl\", // <--- This field allows null",
									"        \"userLocation\",",
									"        \"userLoginEmail\",",
									"        \"userMiddleName\",",
									"        \"userPhoneNumber\",",
									"        \"userTimeZone\",",
									"        \"userVisaStatus\"",
									"    ];",
									"",
									"    response.forEach((obj, idx) => {",
									"        expectedFields.forEach(field => {",
									"            // Check only if the field is actually present in the object",
									"            if (obj.hasOwnProperty(field)) {",
									"                const fieldValue = obj[field];",
									"                ",
									"                // Assertion to check if the value is either a string or null",
									"                pm.expect(fieldValue, `Field '${field}' in object at index ${idx} is neither a string nor null`).to.satisfy(function(value) {",
									"                    return (typeof value === 'string' || value === null);",
									"                });",
									"                ",
									"               ",
									"            }",
									"        });",
									"    });",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "1e5b8b3d-5603-405e-8e59-92e545f2facd",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "e80cbe1f-9783-45b4-97d7-9249fe426e73",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/roles/{{roleId}}",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/roles/R01' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get User for Program",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "906e7666-ce63-4611-89ed-946211acb489",
								"exec": [
									"",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function(){",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"const response = pm.response.json();",
									"console.log(response);",
									"",
									"pm.test(\"Response has all expected fields\", function () {",
									"",
									"    pm.expect(response).to.have.keys([",
									"",
									"        \"userComments\",",
									"        \"userEduPg\",",
									"        \"userEduUg\",",
									"        \"userFirstName\",",
									"        \"userId\",",
									"        \"userLastName\",",
									"        \"userLinkedinUrl\",",
									"        \"userLocation\",",
									"        \"userLoginEmail\",",
									"        \"userMiddleName\",",
									"        \"userPhoneNumber\",",
									"        \"userTimeZone\",",
									"        \"userVisaStatus\"",
									"",
									"    ]);",
									"",
									"});",
									"",
									"pm.test(\"Response has all fields with expected DataType\", function () {",
									"    const response = pm.response.json();",
									"    console.log(response);",
									"    pm.expect(response.userComments).to.be.a('string');",
									"    pm.expect(response.userEduUg).to.be.a('string');",
									"    pm.expect(response.userEduPg).to.be.a('string');",
									"    pm.expect(response.userFirstName).to.be.a('string');",
									"    pm.expect(response.userId).to.be.a('string');",
									"    pm.expect(response.userLastName).to.be.a('string');",
									"    pm.expect(response.userLinkedinUrl).to.be.a('string');",
									"    pm.expect(response.userLocation).to.be.a('string');",
									"    pm.expect(response.userLoginEmail).to.be.a('string');",
									"    pm.expect(response.userMiddleName).to.be.a('string');",
									"    pm.expect(response.userPhoneNumber).to.be.a('string');",
									"    pm.expect(response.userTimeZone).to.be.a('string');",
									"    pm.expect(response.userVisaStatus).to.be.a('string');",
									"",
									"});",
									"",
									"const userDtoSchema = {",
									"    \"type\": \"object\",",
									"    \"properties\": {",
									"        \"userId\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userFirstName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userLastName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userMiddleName\": {",
									"            // CORRECTED: Allow null for optional fields like middle name",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userPhoneNumber\": {",
									"            \"type\": \"string\", // Mandatory field, so only string",
									"            \"description\": \"Phone number must follow the format +XX XXXXXXXXXX (e.g., +1 5551234567).\",",
									"            \"pattern\": \"^\\\\+\\\\d{1,2} \\\\d{10}$\"",
									"        },",
									"        \"userLocation\": {",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userTimeZone\": {",
									"            \"type\": [\"string\", \"null\"]",
									"        },",
									"        \"userLinkedinUrl\": {",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userEduUg\": {",
									"            // CORRECTED: Allow null for optional education fields",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userEduPg\": {",
									"            // CORRECTED: Allow null for optional education fields",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userComments\": {",
									"            // CORRECTED: Allow null for optional comments field",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userVisaStatus\": {",
									"            // CORRECTED: Allow null for optional visa status field",
									"            \"type\": [\"string\", \"null\"] ",
									"        },",
									"        \"userLoginEmail\": {",
									"            \"type\": [\"string\", \"null\"], ",
									"            \"description\": \"The user's login email address must follow a general email pattern.\",",
									"            \"pattern\": \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\"",
									"        }",
									"    },",
									"    \"required\": [",
									"        \"userId\", // Added as it seems fundamental",
									"        \"userFirstName\",",
									"        \"userLastName\",",
									"        \"userPhoneNumber\",",
									"        \"userLoginEmail\" ",
									"    ],",
									"    \"additionalProperties\": false",
									"};",
									"",
									"// Define the final schema as an ARRAY of the User DTO objects",
									"const userArraySchema = {",
									"    \"type\": \"array\",",
									"    \"items\": userDtoSchema,",
									"    \"description\": \"The root response must be an array of user objects.\"",
									"};",
									"",
									"",
									"pm.test(\"Response body adheres to the Array of User DTO JSON Schema\", function () {",
									"    try {",
									"        // Core validation using Postman's built-in function",
									"        pm.response.to.have.jsonSchema(userArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e;",
									"    }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "8d29598e-3f7d-4dda-83cb-063ea7faaf00",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "535dce52-7917-457f-a8ab-72ac7f58a46c",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/programs/{{programId}}",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/programs/49' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get User by Program Batches",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "3d369380-61d0-49a2-b7df-f83e626482cf",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"const responseArray = pm.response.json();",
									"console.log(responseArray);",
									"",
									"pm.test(\"Response has all expected fields\", function () {",
									"    pm.expect(responseArray[0]).to.have.keys([",
									"        \"userComments\",",
									"        \"userEduPg\",",
									"        \"userEduUg\",",
									"        \"userFirstName\",",
									"        \"userId\",",
									"        \"userLastName\",",
									"        \"userLinkedinUrl\",",
									"        \"userLocation\",",
									"        \"userLoginEmail\",",
									"        \"userMiddleName\",",
									"        \"userPhoneNumber\",",
									"        \"userTimeZone\",",
									"        \"userVisaStatus\"",
									"    ]);",
									"});",
									"",
									"pm.test(\"Response has all fields with expected DataType\", function () {",
									"    const responseArray = pm.response.json();",
									"    const firstObject = responseArray[0];",
									"    pm.expect(firstObject.userComments === undefined || typeof firstObject.userComments === 'string').to.be.true;",
									"    pm.expect(typeof firstObject.userEduUg).to.eql('string');",
									"    pm.expect(typeof firstObject.userEduPg).to.eql('string');",
									"    pm.expect(typeof firstObject.userFirstName).to.eql('string');",
									"    pm.expect(typeof firstObject.userId).to.eql('string');",
									"    pm.expect(typeof firstObject.userLastName).to.eql('string');",
									"    pm.expect(typeof firstObject.userLinkedinUrl).to.eql('string');",
									"    pm.expect(typeof firstObject.userLocation).to.eql('string');",
									"    pm.expect(",
									"        typeof firstObject.userLoginEmail === 'string' || firstObject.userLoginEmail === null",
									"    ).to.be.true;",
									"    pm.expect(firstObject.userMiddleName === undefined || typeof firstObject.userMiddleName === 'string').to.be.true;",
									"    pm.expect(typeof firstObject.userPhoneNumber).to.eql('string');",
									"    pm.expect(typeof firstObject.userTimeZone).to.eql('string');",
									"    pm.expect(typeof firstObject.userVisaStatus).to.eql('string');",
									"});",
									"",
									"const userDtoSchema = {",
									"    \"type\": \"object\",",
									"    \"properties\": {",
									"        \"userId\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userFirstName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userLastName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        // ... (truncated for brevity)",
									"    }",
									"};",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "dd13a071-5c40-4ec4-acd9-4b5b0f781c6b",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/programBatch/{{batchId}}",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/programBatch/01' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get User Details by Id",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "2c58c933-c710-4fa2-8bf3-33093e5faea8",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"pm.test(\"Response is an array\", function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array');",
									"});",
									"pm.test(\"Each object in array has all expected fields with correct types\", function () {",
									"    const response = pm.response.json();",
									"    response.forEach(function(obj, idx) {",
									"        pm.expect(obj, `Object at index ${idx} is missing expected fields`).to.have.keys([",
									"            \"programName\",",
									"            \"batchName\",",
									"            \"userFirstName\",",
									"            \"userLastName\",",
									"            \"userLoginEmail\"",
									"        ]);",
									"        pm.expect(obj.programName, `programName at index ${idx} is not a string`).to.be.a('string');",
									"        pm.expect(obj.batchName, `batchName at index ${idx} is not a string`).to.be.a('string');",
									"        pm.expect(obj.userFirstName, `userFirstName at index ${idx} is not a string`).to.be.a('string');",
									"        pm.expect(obj.userLastName, `userLastName at index ${idx} is not a string`).to.be.a('string');",
									"        pm.expect(obj.userLoginEmail, `userLoginEmail at index ${idx} is not a string`).to.be.a('string');",
									"    });",
									"});",
									"",
									"const enrollmentDtoSchema = {",
									"    \"type\": \"object\",",
									"    \"properties\": {",
									"        \"programName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"batchName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userFirstName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userLastName\": {",
									"            \"type\": \"string\"",
									"        },",
									"        \"userLoginEmail\": {",
									"            \"type\": \"string\",",
									"            \"description\": \"The user's login email address.\"",
									"        }",
									"    },",
									"    \"required\": [",
									"        \"userFirstName\",",
									"        \"userLastName\"",
									"    ], ",
									"    \"additionalProperties\": false",
									"};",
									"",
									"const enrollmentArraySchema = {",
									"    \"type\": \"array\",",
									"    \"items\": enrollmentDtoSchema,",
									"    \"description\": \"The root response must be an array of enrollment objects.\"",
									"};",
									"",
									"",
									"pm.test(\"Response body adheres to the Array of Enrollment DTO JSON Schema\", function () {",
									"    try {",
									"        // Core validation using Postman's built-in function",
									"        pm.response.to.have.jsonSchema(enrollmentArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e; ",
									"    }",
									"});",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "2233a845-cc69-451e-b679-659af0ad86ad",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/details/{{userId}}",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/details/U01' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get Count Of Active and Inactive Users. Unless role is specified,Get all type of users",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "de389661-ba07-40db-9061-5bc5f52ce944",
								"exec": [
									"pm.test(\"Response is an array\", function () {",
									"    var jsonData = pm.response.json();",
									"    pm.expect(Array.isArray(jsonData)).to.be.true;",
									"});",
									"",
									"pm.test(\"Each element has 'status' (string) and 'count' (number)\", function () {",
									"    var jsonData = pm.response.json();",
									"    jsonData.forEach(function(item) {",
									"        pm.expect(item).to.have.property('status').that.is.a('string');",
									"        pm.expect(item).to.have.property('count').that.is.a('number');",
									"    });",
									"});",
									"const userCountDtoSchema = {",
									"    \"type\": \"object\",",
									"    \"properties\": {",
									"        \"status\": {",
									"            \"type\": \"string\",",
									"            \"description\": \"The status identifier (e.g., 'Active', 'Inactive').\",",
									"        },",
									"        \"count\": {",
									"            \"type\": \"integer\", ",
									"            \"description\": \"The count of users with the specified status.\"",
									"        }",
									"    },",
									"    // Both fields must be present in the response object",
									"    \"required\": [\"status\", \"count\"], ",
									"    \"additionalProperties\": false",
									"};",
									"",
									"// Define the final schema as an ARRAY of the UserCountByStatusDTO objects",
									"const userCountArraySchema = {",
									"    \"type\": \"array\",",
									"    \"items\": userCountDtoSchema,",
									"    \"description\": \"The root response must be an array of status count objects.\"",
									"};",
									"",
									"",
									"pm.test(\"Response body adheres to the Array of UserCountByStatus DTO JSON Schema\", function () {",
									"    try {",
									"        // Core validation using Postman's built-in function",
									"        pm.response.to.have.jsonSchema(userCountArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e; ",
									"    }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "bdd1f153-a334-445f-8783-5ad758a57e08",
								"exec": [
									"// Retrieve the base URL from the collection variables",
									"var baseUrl = pm.collectionVariables.get(\"baseUrl\");",
									"",
									"// Retrieve the specific endpoint for this iteration from the data file",
									"var endPoint = pm.iterationData.get(\"apiEndpoint\");",
									"console.log(\"endPoint:\", endPoint);",
									"",
									"// Concatenate them to form the full URL",
									"var constructedUrl = baseUrl + endPoint;",
									"",
									"console.log(\"constructedUrl:\", constructedUrl);",
									"",
									"pm.request.url = constructedUrl;",
									"",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "3ceeb767-bf2b-436b-9cd0-0b92b3fc73bb",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/byStatus",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/byStatus?id=all' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get All Active User",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "6475b046-a5fa-4dc2-b414-146472c21130",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function(){",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"pm.test(\"Response is an array\", function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array');",
									"});",
									"pm.test(\"Each user object has all expected fields\", function () {",
									"    const response = pm.response.json();",
									"    const expectedFields = [",
									"        \"userId\",",
									"        \"userFirstName\",",
									"        \"userLastName\",",
									"        \"userMiddleName\",",
									"        \"userPhoneNumber\",",
									"        \"userLocation\",",
									"        \"userTimeZone\",",
									"        \"userLinkedinUrl\",",
									"        \"userEduUg\",",
									"        \"userEduPg\",",
									"        \"userComments\",",
									"        \"userVisaStatus\",",
									"        \"userLoginEmail\"",
									"    ];",
									"    response.forEach(function(user, idx) {",
									"        pm.expect(user, `User at index ${idx} is missing fields`).to.have.all.keys(expectedFields);",
									"    });",
									"});",
									"",
									"",
									"// Define the comprehensive JSON Schema for the UserDto object.",
									"const userDtoSchema = {",
									"    \"type\": \"object\",",
									"    \"properties\": {",
									"        \"userId\": { \"type\": \"string\" },",
									"        \"userFirstName\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z][a-zA-Z ]+$\" },",
									"        \"userLastName\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z]+$\" },",
									"        \"userMiddleName\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z]+$\" },",
									"        \"userPhoneNumber\": { \"type\": \"string\", \"pattern\": \"^\\\\+\\\\d{1,2} \\\\d{10}$\" },",
									"        \"userLocation\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z][a-zA-Z ]+$\" },",
									"        \"userTimeZone\": { \"type\": \"string\" },",
									"        \"userLinkedinUrl\": { \"type\": \"string\", \"pattern\": \".*www.linkedin.com.*\" },",
									"        \"userEduUg\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\" },",
									"        \"userEduPg\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\" },",
									"        \"userComments\": { \"type\": \"string\" },",
									"        \"userVisaStatus\": { \"type\": \"string\" },",
									"        \"userLoginEmail\": { \"type\": \"string\", \"pattern\": \"^[a-zA-Z0-9][a-zA-Z0-9.]+@gmail\\\\.com$\" }",
									"    },",
									"    \"required\": [",
									"        \"userFirstName\",",
									"        \"userLastName\",",
									"        \"userPhoneNumber\",",
									"        \"userLoginEmail\"",
									"    ],",
									"    \"additionalProperties\": false",
									"};",
									"",
									"// Define the final schema as an Array of the UserDto objects",
									"const userDtoArraySchema = {",
									"    \"type\": \"array\",",
									"    \"items\": userDtoSchema",
									"};",
									"",
									"",
									"// 2. Full Schema Validation (Schema Only)",
									"",
									"pm.test(\"Response body adheres to the Array of User DTO JSON Schema\", function () {",
									"    try {",
									"        // Core validation using Postman's built-in function",
									"        pm.response.to.have.jsonSchema(userDtoArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e; ",
									"    }",
									"});",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "af8c9c4c-5b4a-4fcd-ad4b-5681fb12b873",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/users/activeUsers",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/users/activeUsers' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get All Roles",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "b399ad2b-9f5f-4172-b9b7-f3efc8a9e437",
								"exec": [
									"",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"pm.test(\"Response includes all required fields\", function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array', 'Response should be an array of objects.');",
									"",
									"    const expectedKeys = [",
									"        \"creationTime\",",
									"        \"lastModTime\",",
									"        \"roleDesc\",",
									"        \"roleId\",",
									"        \"roleName\"",
									"    ];",
									"",
									"    response.forEach((roleObject, index) => {",
									"        pm.expect(roleObject, `Object at index ${index} is missing required keys.`)",
									"            .to.have.all.keys(expectedKeys);",
									"    });",
									"});",
									"",
									"",
									"",
									"pm.test(\"Response has all fields with expected DataType\", function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array', 'Response should be an array of objects.');",
									"    response.forEach((roleObject, index) => {",
									"        pm.expect(roleObject.creationTime, `creationTime at index ${index} should be a string`).to.be.a('string');",
									"        pm.expect(roleObject.lastModTime, `lastModTime at index ${index} should be a string`).to.be.a('string');",
									"        pm.expect(roleObject.roleDesc, `roleDesc at index ${index} should be a string`).to.be.a('string');",
									"        pm.expect(roleObject.roleId, `roleId at index ${index} should be a string`).to.be.a('string');",
									"        pm.expect(roleObject.roleName, `roleName at index ${index} should be a string`).to.be.a('string');",
									"    });",
									"});",
									"",
									"const roleDtoArraySchema = {",
									"    \"type\": \"array\",",
									"",
									"",
									"    \"items\": {",
									"        // Each item must be an object {}.",
									"        \"type\": \"object\",",
									"",
									"        // Define the properties (fields) and their validation rules for EACH role object.",
									"        \"properties\": {",
									"            \"creationTime\": {",
									"                \"type\": \"string\",",
									"                \"description\": \"Timestamp of creation (ISO 8601 string format).\"",
									"            },",
									"            \"lastModTime\": {",
									"                \"type\": \"string\",",
									"                \"description\": \"Timestamp of last modification (ISO 8601 string format).\"",
									"            },",
									"            \"roleDesc\": {",
									"                \"type\": \"string\",",
									"                \"description\": \"Description of the role.\"",
									"            },",
									"            \"roleId\": {",
									"                \"type\": \"string\",",
									"                \"description\": \"Unique identifier for the role.\"",
									"            },",
									"            \"roleName\": {",
									"                \"type\": \"string\",",
									"                \"description\": \"The human-readable name of the role.\"",
									"            }",
									"        },",
									"",
									"        // List all properties as required for EACH role object.",
									"        \"required\": [",
									"            \"creationTime\",",
									"            \"lastModTime\",",
									"            \"roleDesc\",",
									"            \"roleId\",",
									"            \"roleName\"",
									"        ],",
									"",
									"        // Prevents the API from returning any fields not defined in this schema for each object.",
									"        \"additionalProperties\": false",
									"    }",
									"};",
									"",
									"pm.test(\"Response body adheres to the RoleDto Array JSON Schema\", function () {",
									"    try {",
									"        // Core validation using Postman's built-in function",
									"        pm.response.to.have.jsonSchema(roleDtoArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e;",
									"    }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "3905e4eb-00e9-4caf-a785-44122a7268c1",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "d99be460-1816-4286-a1d7-13ff737bec5e",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg"
							}
						],
						"url": "{{baseUrl}}/roles",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/roles' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjM5NDIyMzUsImV4cCI6MTc2Mzk3MTAzNX0.2WtvKomHtzw-9srzykxb65JfMcgf8-Vs5WJkLpEkwcf008M66bJqS4xN9tMvwmRVBjrNxpvvd4BMTzRBWcuJyg'"
					},
					"response": []
				},
				{
					"name": "Get email of all Users with active status",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "596b7d29-2141-45b2-bbec-26e08cc82df1",
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"pm.test(\"Status description is OK\", function () {",
									"    pm.expect(pm.response.reason()).to.eql('OK');",
									"});",
									"pm.test(\"Content-Type is present\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"});",
									"",
									"const emailDtoArraySchema = {",
									"    // 1. The root response body structure MUST be an array of strings.",
									"    \"type\": \"array\",",
									"",
									"    // 2. The 'items' property defines the schema for every element in the array.",
									"    \"items\": {",
									"        // Each item must be a string.",
									"        \"type\": \"string\",",
									"",
									"        \"description\": \"Each item in the array must be a string that represents a valid email address.\",",
									"",
									"    }",
									"};",
									"// 2. Full Schema Validation",
									"",
									"pm.test(\"Response body adheres to the Array of Email Strings JSON Schema\", function () {",
									"    try {",
									"        // Use the schema for array validation",
									"        pm.response.to.have.jsonSchema(emailDtoArraySchema);",
									"    } catch (e) {",
									"        // Log detailed error if validation fails",
									"        console.error(\"Schema Validation Failed:\", e.message);",
									"        // Re-throw to fail the test in the Postman Test Results pane",
									"        throw e;",
									"    }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "305cd45f-d6d2-489e-b949-4d7c6f4e5512",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "accept",
								"value": "*/*"
							},
							{
								"key": "Authorization",
								"value": "Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjQwMTg0MjcsImV4cCI6MTc2NDA0NzIyN30.uJun-u-Hk3FbpfC7tPzThgh0fihBeWkj4ebr-BAPKX_hOXCP2gwtxs_bae37MvFIalm1ochhUwukd6T7_nYRsA"
							}
						],
						"url": "{{baseUrl}}/fetch-emails",
						"description": "Generated from cURL: curl -X 'GET' \\\n  'https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms/fetch-emails' \\\n  -H 'accept: */*' \\\n  -H 'Authorization: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNUBnbWFpbC5jb20iLCJpYXQiOjE3NjQwMTg0MjcsImV4cCI6MTc2NDA0NzIyN30.uJun-u-Hk3FbpfC7tPzThgh0fihBeWkj4ebr-BAPKX_hOXCP2gwtxs_bae37MvFIalm1ochhUwukd6T7_nYRsA'"
					},
					"response": []
				}
			],
			"id": "7267c003-ea5b-4364-acf0-e45a52c14079",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "0b756eec-f2c0-4fc9-9b68-1f53d68d80f6",
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// ----------------------------------------------------------------\r",
							"// 1. SKIP LOGIC (Traffic Cop)\r",
							"// ----------------------------------------------------------------\r",
							"var targetRequest = pm.iterationData.get(\"Request Name\");\r",
							"var currentRequest = pm.info.requestName;\r",
							"// If RequestName is defined in CSV, only run that specific request\r",
							"if (targetRequest && targetRequest !== currentRequest) {\r",
							"    pm.execution.skipRequest();\r",
							"    return; // Stop executing the rest of the script\r",
							"}\r",
							"\r",
							"var csvPayload = pm.iterationData.get(\"Payload\");\r",
							"if (csvPayload) {\r",
							"    if (typeof csvPayload === 'object') {\r",
							"        // It's a JSON object (from JSON file) -> Stringify it for the Body\r",
							"        pm.collectionVariables.set(\"Payload\", JSON.stringify(csvPayload));\r",
							"    } else {\r",
							"        // It's a String (from CSV) -> Try to parse/clean it\r",
							"        try {\r",
							"            var obj = JSON.parse(csvPayload);\r",
							"            pm.collectionVariables.set(\"Payload\", JSON.stringify(obj));\r",
							"        } catch (e) {\r",
							"            pm.collectionVariables.set(\"Payload\", csvPayload);\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"var overrideStatus = pm.iterationData.get(\"Token Override\");\r",
							"\r",
							"if (overrideStatus === \"invalid\") {\r",
							"    // Use 'pm.request.auth.bearer' to directly modify the Auth Helper\r",
							"    // This is the most direct way to tell the Auth Tab \"Use THIS token, not the variable\"\r",
							"    pm.request.auth.use(\"bearer\", {\r",
							"        token: \"INVALID_TOKEN_12345\"\r",
							"    });\r",
							"    \r",
							"    console.log(\"Updated Auth Tab directly with INVALID token\");\r",
							"}"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "9125ea7b-3e60-4f95-927f-86175ecf938d",
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// Content-Type Check (Safe Version)\r",
							"pm.test(\"Content-Type is application/json\", function () {\r",
							"    if (pm.response.headers.has(\"Content-Type\")) {\r",
							"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
							"    } else {\r",
							"        console.warn(\"Content-Type header missing. Skipping check.\");\r",
							"    }\r",
							"});\r",
							"\r",
							"\r",
							"\r",
							"\r",
							""
						]
					}
				}
			]
		},
		{
			"name": "ProgramController",
			"item": [
				{
					"name": "CreateProgram",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "7cf5919a-4645-4506-839a-cdb918553147",
								"exec": [
									"let response = pm.response.json(); // To store the response",
									"",
									"let expected = JSON.parse(pm.iterationData.get(\"Expected Response Body\")); // Convert json object from string (from csv file)",
									"",
									"// retrieve expected status from a json object",
									"const respCd = pm.iterationData.get(\"Expected Status\");",
									"",
									"//Checks repsonse has valid json structure",
									"pm.test(\"Response has valid structure\", function () {",
									"    pm.expect(response).to.be.an('object');",
									"});",
									"",
									"//Checks repsonse status code is 201 or 400 based on the expected status code in csv file",
									"if (pm.response.code === 201) {",
									"    pm.test(\"Status code is 201\", function () {",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));",
									"    });",
									"// schema Verification",
									"    pm.test(\"Validate Response Keys\", function () {",
									"        pm.expect(response).to.have.property('programId').that.is.a('number');",
									"        pm.expect(response).to.have.property(\"programName\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');",
									"        pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');",
									"        pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');",
									"        pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');",
									"    });",
									"//Set collectionVariables",
									"    pm.collectionVariables.set(\"programId\", response.programId);",
									"    pm.collectionVariables.set(\"programName\", response.programName);",
									"",
									"//Data validation for is not empty",
									"    pm.test(\"Program name and status is not empty\", function () {",
									"        pm.expect(response.programId).to.be.a('number').and.to.be.above(0);",
									"        pm.expect(response.programName).to.be.a('string').and.not.empty;",
									"        pm.expect(response.programStatus).to.be.a('string').and.not.empty;",
									"    });",
									"// Response data validation",
									"    pm.test(\"Verify Program Response\", function () {",
									"        pm.expect(response.programName).to.eql(expected.programName);",
									"        pm.expect(response.programDescription).to.eql(expected.programDescription);",
									"        pm.expect(response.programStatus).to.eql(expected.programStatus);",
									"    });",
									"} else {",
									"",
									"    //checks response status code is 400 or 404 based on the expected status code in csv file",
									"    pm.test(\"Status code is 400\", function () {",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));",
									"    });",
									"",
									"//Field verification",
									"    pm.test(\"Validate Error Response Keys\", function () {",
									"        pm.expect(response).to.have.property('message').that.is.a('string');",
									"        pm.expect(response).to.have.property('success').that.is.a('boolean');",
									"    });",
									"",
									" //Response data validation for error response",
									"    pm.test(\"Verify Error Response\", function () {",
									"        pm.expect(response.message).to.eql(expected.message);",
									"        pm.expect(response.success).to.eql(expected.success);",
									"    });",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "9a70d851-af9e-48d8-8a06-eb099fcd7c6b",
								"exec": [
									"//Checks if the endpoint in the file matches the expected endpoint for the request. If it does, the request is executed. If not, the request is skipped.\r",
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"//Checks urlFromFile is empty or does not include \"saveprogram\", the request is skipped. If it does, the request is executed.\r",
									"if (urlFromFile && urlFromFile.includes(\"saveprogram\")) {\r",
									"    console.log(\"CreateProgram: Endpoint matched. Executing request.\");\r",
									"} else {\r",
									"    console.log(\"CreateProgram: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "294c821a-6ea7-4cd5-9a5e-510963c6b60e",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/saveprogram"
					},
					"response": []
				},
				{
					"name": "UpdateProgramById",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "90f71e16-6c90-4c25-8777-04f65cd3d0e4",
								"exec": [
									"//Checks if the response keys are as expected.\r",
									"let response = pm.response.json();\r",
									"\r",
									"let expected = pm.iterationData.get(\"Expected Response Body\");\r",
									"\r",
									"expected = pm.variables.replaceIn(expected);\r",
									"\r",
									"//Checks if the response has the expected keys.\r",
									"expected = JSON.parse(expected);\r",
									"\r",
									"//Checks if repsonse has expected keys\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"//Checks if response has valid structure\r",
									"pm.test(\"Response has valid structure\", function () {\r",
									"    pm.expect(response).to.be.an('object');\r",
									"});\r",
									"\r",
									"//Checks if response status code is as expected.\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"Status code is 200\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate Response Keys\", function () {\r",
									"        pm.expect(response).to.have.property('programId').that.is.a('number');\r",
									"        pm.expect(response).to.have.property(\"programName\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');\r",
									"        pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');\r",
									"        pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');\r",
									"        pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');\r",
									"    });\r",
									"\r",
									"    pm.test(\"Program name and status is not empty\", function () {\r",
									"        pm.expect(response.programId).to.be.a('number').and.to.be.above(0);\r",
									"        pm.expect(response.programName).to.be.a('string').and.not.empty;\r",
									"        pm.expect(response.programStatus).to.be.a('string').and.not.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(\"Verify Program Response\", function () {\r",
									"        pm.expect(response.programName).to.eql(expected.programName);\r",
									"        pm.expect(response.programDescription).to.eql(expected.programDescription);\r",
									"        pm.expect(response.programStatus).to.eql(expected.programStatus);\r",
									"    });\r",
									"} else if (pm.response.code === 400) {\r",
									"    pm.test(\"Status code is 400\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate message and success fields\", function () {\r",
									"        pm.expect(response.message).to.eql(expected.message);\r",
									"        pm.expect(response.success).to.eql(expected.success);\r",
									"    });\r",
									"} else if (pm.response.code === 404) {\r",
									"    pm.test(\"Validatte invalid Program Id\", function () {\r",
									"        pm.expect(response.message).to.eql(expected.message);\r",
									"        pm.expect(response.success).to.eql(expected.success);\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "94222f6b-e98e-4ce9-890d-de4c383c5328",
								"exec": [
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"const expectedStatus = pm.iterationData.get(\"Expected Status\");\r",
									"const invalidInput = pm.iterationData.get(\"InvalidInput\");\r",
									"\r",
									"if (urlFromFile && urlFromFile.includes(\"putprogram/\")) {\r",
									"    console.log(\"UpdateProgramById: Endpoint matched. Executing request.\");\r",
									"    const collectProgramId = pm.collectionVariables.get(\"programId\");\r",
									"    \r",
									"    if (Number(expectedStatus) === 404) {\r",
									"        pm.variables.set(\"programId\", Number(invalidInput));\r",
									"    }\r",
									"    else {\r",
									"        pm.variables.set(\"programId\", collectProgramId);\r",
									"    }\r",
									"} else {\r",
									"    console.log(\"UpdateProgramById: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "4f9729c5-8d72-447d-8992-d9b528c72e71",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/putprogram/{{programId}}"
					},
					"response": []
				},
				{
					"name": "UpdateProgramByName",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "0dfc3882-40f0-4313-beab-190536387930",
								"exec": [
									"// Parse response and expected data from iteration file",
									"let response = pm.response.json();",
									"let expected = pm.iterationData.get(\"Expected Response Body\");",
									"expected = pm.variables.replaceIn(expected);",
									"expected = JSON.parse(expected);",
									"const respCd = pm.iterationData.get(\"Expected Status\");",
									"",
									"// Verify response is an object",
									"pm.test(\"Response has valid structure\", function () {",
									"    pm.expect(response).to.be.an('object');",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"    // Validate status code matches expected",
									"    pm.test(\"Status code is 201\", function () {",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));",
									"    });",
									"",
									"    // Validate all required response properties and types",
									"    pm.test(\"Validate Response Keys\", function () {",
									"        pm.expect(response).to.have.property('programId').that.is.a('number');",
									"        pm.expect(response).to.have.property(\"programName\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');",
									"        pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');",
									"        pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');",
									"        pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');",
									"        pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');",
									"    });",
									"",
									"    // Store program description for subsequent requests",
									"    pm.collectionVariables.set(\"programDescription\", response.programDescription);",
									"",
									"    // pm.test(\"Program status is valid\", function () {",
									"    //     const jsonData = pm.response.json();",
									"    //     pm.expect(jsonData.programStatus).to.equal('Active');",
									"    // });",
									"",
									"    // pm.collectionVariables.set(\"programId\", response.programId);",
									"    // pm.collectionVariables.set(\"programName\", response.programName);",
									"",
									"    // Verify critical fields are not empty",
									"    pm.test(\"Program name and status is not empty\", function () {",
									"        pm.expect(response.programId).to.be.a('number').and.to.be.above(0);",
									"        pm.expect(response.programName).to.be.a('string').and.not.empty;",
									"        pm.expect(response.programStatus).to.be.a('string').and.not.empty;",
									"    });",
									"",
									"    pm.test(\"Verify Program Response\", function () {",
									"        pm.expect(response.programName).to.eql(expected.programName);",
									"        pm.expect(response.programDescription).to.eql(expected.programDescription);",
									"        pm.expect(response.programStatus).to.eql(expected.programStatus);",
									"    });",
									"} else if (pm.response.code === 400) {",
									"    pm.test(\"Status code is 400\", function () {",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));",
									"    });",
									"",
									"    pm.test(\"Validate message and success fields\", function () {",
									"        pm.expect(response.message).to.eql(expected.message);",
									"        pm.expect(response.success).to.eql(expected.success);",
									"    });",
									"}",
									"else if (pm.response.code === 404) {",
									"    pm.test(\"Validatte invalid Program Id\", function () {",
									"        pm.expect(response.message).to.eql(expected.message);",
									"        pm.expect(response.success).to.eql(expected.success);",
									"    });",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "10b3066d-f8e2-45e9-ac0a-429b62b2820d",
								"exec": [
									"// Get test data from iteration file",
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");",
									"const expectedStatus = pm.iterationData.get(\"Expected Status\");",
									"const invalidInput = pm.iterationData.get(\"InvalidInput\");",
									"",
									"// Check if endpoint matches this request's pattern",
									"if (urlFromFile && urlFromFile.includes(\"program/\") && !urlFromFile.includes(\"putprogram\")) {",
									"    console.log(\"UpdateProgramByName: Endpoint matched. Executing request.\");",
									"    const collectProgramName = pm.collectionVariables.get(\"programName\");",
									"    // Set invalid program name for 404 test scenarios",
									"    if (Number(expectedStatus) === 404) {",
									"        pm.variables.set(\"programName\", invalidInput);",
									"    }",
									"    else {",
									"        pm.variables.set(\"programName\", collectProgramName);",
									"    }",
									"} else {",
									"    console.log(\"UpdateProgramByName: Endpoint not matched. Skipping request.\");",
									"    // Skip execution if endpoint doesn't match",
									"    pm.execution.skipRequest();",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "4c32ec74-fc26-4e52-8cc5-1a162446d4bf",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/program/{{programName}}"
					},
					"response": []
				},
				{
					"name": "DeleteProgramById",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "46f86b08-1818-4bcf-a41b-4f8704e0ec55",
								"exec": [
									"let response = pm.response.text();\r",
									"let expected = pm.iterationData.get(\"Expected Response Body\");\r",
									"expected = pm.variables.replaceIn(expected);\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"Status code is 200\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(respCd);\r",
									"        pm.collectionVariables.set(\"DeleteByPgmIdRespCd\", true);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate full response\", function () {\r",
									"        pm.expect(response).to.eql(expected);\r",
									"    });\r",
									"} else if (pm.response.code === 404) {\r",
									"    let parsedExpected = JSON.parse(expected);\r",
									"//    response = JSON.parse(response);\r",
									"    pm.test(\"Validate invalid Program Id\", function () {\r",
									"        pm.expect(response.message).to.eql(parsedExpected.message);\r",
									"        pm.expect(response.success).to.eql(parsedExpected.success);\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.variables.unset(\"programId\");\r",
									"pm.collectionVariables.set(\"DeleteByPgmIdExecuted\", true);\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "8dead541-73c5-42b0-bcf0-ab5437fded53",
								"exec": [
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"const expectedStatus = pm.iterationData.get(\"Expected Status\");\r",
									"const invalidInput = pm.iterationData.get(\"InvalidInput\");\r",
									"\r",
									"if (urlFromFile && urlFromFile.includes(\"deletebyprogid/\")) {\r",
									"    console.log(\"DeleteProgramById: Endpoint matched. Executing request.\");\r",
									"    const collectProgramId = pm.collectionVariables.get(\"programId\");\r",
									"    if (Number(expectedStatus) === 404) {\r",
									"        pm.variables.set(\"programId\", Number(invalidInput));\r",
									"    }\r",
									"    else {\r",
									"        pm.variables.set(\"programId\", collectProgramId);\r",
									"    }\r",
									"} else {\r",
									"    console.log(\"DeleteProgramById: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "29c5cbd0-6909-4ed4-90ef-b473ac28cf8b",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "DELETE",
						"header": [],
						"url": "{{baseUrl}}/deletebyprogid/{{programId}}"
					},
					"response": []
				},
				{
					"name": "VerifyDeleteProgramById",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "a711d155-2be6-4440-b9f7-9e4d704dc297",
								"exec": [
									"let response = pm.response.json();\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.expect(pm.response.code).to.equal(respCd);\r",
									"});\r",
									"\r",
									"pm.test(\"Validate Response Keys\", function () {\r",
									"    pm.expect(response).to.have.property('programId').that.is.a('number');\r",
									"    pm.expect(response).to.have.property(\"programName\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');\r",
									"    pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');\r",
									"    pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');\r",
									"    pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"pm.test(\"Validate Response Values\", function () {\r",
									"    pm.expect(response.programId).to.equal(pm.collectionVariables.get(\"programId\"));\r",
									"    pm.expect(response.programName).to.not.be.empty;\r",
									"    pm.expect(response.programName).to.equal(pm.collectionVariables.get(\"programName\"));\r",
									"    pm.expect(response.programDescription).to.not.be.empty;\r",
									"    pm.expect(response.programDescription).to.equal(pm.collectionVariables.get(\"programDescription\"));\r",
									"    pm.expect(response.programStatus).to.equal(\"Inactive\");\r",
									"});\r",
									"\r",
									"pm.collectionVariables.set(\"GetProgramDlteByIdExecuted\", true);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "dc314bbd-a01f-4207-9cd1-a14f08068f19",
								"exec": [
									"const executed = pm.collectionVariables.get(\"DeleteByPgmIdExecuted\");\r",
									"const executeRspCd = pm.collectionVariables.get(\"DeleteByPgmIdRespCd\");\r",
									"\r",
									"if (executed === true && executeRspCd == true) {\r",
									"    console.log(\"GetProgramDeleteById: Endpoint matched. Executing request.\");\r",
									"    pm.collectionVariables.set(\"DeleteByPgmIdExecuted\", false);\r",
									"    pm.collectionVariables.set(\"DeleteByPgmIdRespCd\", false);\r",
									"} else {\r",
									"    console.log(\"GetProgramDeleteById: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "61b71bda-70a3-4836-95d9-a89a6003a52d",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/programs/{{programId}}"
					},
					"response": []
				},
				{
					"name": "UpdateProgramStatustoActive",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "eda0168a-f9bd-4127-9bcc-348c0df0510f",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "aab6f10e-2f24-4def-a18f-a2254c28b5c3",
								"exec": [
									"const executed = pm.collectionVariables.get(\"GetProgramDlteByIdExecuted\");\r",
									"\r",
									"if (executed === true) {\r",
									"   pm.collectionVariables.set(\"GetProgramDlteByIdExecuted\", false);\r",
									"\r",
									"} else {\r",
									"    console.log(\"UpdateProgram: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "a6052e6c-298f-4a97-9f34-7befe83449a8",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n\"programDescription\": \"{{programDescription}}\",\r\n\"programName\": \"{{programName}}\",\r\n\"programStatus\": \"Active\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/putprogram/{{programId}}"
					},
					"response": []
				},
				{
					"name": "DeleteProgramByName",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "7480fe7f-1738-495c-8415-e996de106c39",
								"exec": [
									"const urlFromDataFile = pm.iterationData.get(\"Endpoint\");\r",
									"const expectedStatus = pm.iterationData.get(\"Expected Status\");\r",
									"const invalidInput = pm.iterationData.get(\"InvalidInput\");\r",
									"\r",
									"if (urlFromDataFile && urlFromDataFile.includes(\"deletebyprogname/\")) {\r",
									"    console.log(\"DeleteProgramByName: Endpoint matched. Executing request.\");\r",
									"    const collectProgramName = pm.collectionVariables.get(\"programName\");\r",
									"\r",
									"    if (Number(expectedStatus) === 404) {\r",
									"        pm.variables.set(\"programName\", invalidInput);\r",
									"    }\r",
									"    else {\r",
									"        pm.variables.set(\"programName\", collectProgramName);\r",
									"    }\r",
									"\r",
									"\r",
									"} else {\r",
									"    console.log(\"DeleteProgramByName: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "3ad1c026-ec0e-420f-a2e1-6cf4f9b1cf78",
								"exec": [
									"let response = pm.response.text();\r",
									"let expected = pm.iterationData.get(\"Expected Response Body\");\r",
									"expected = pm.variables.replaceIn(expected);\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"Status code is 201\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"        pm.collectionVariables.set(\"DeleteByPgmNmeRespCd\", true);\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate response\", function () {\r",
									"        pm.expect(response).to.eql(expected);\r",
									"    });\r",
									"} else if (pm.response.code === 404) { \r",
									"    let parsedExpected = JSON.parse(expected);\r",
									"    pm.test(\"Status code is 404\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"    });\r",
									"    pm.test(\"Validate message and success fields\", function () {\r",
									"        pm.expect(response.message).to.eql(parsedExpected.message);\r",
									"        pm.expect(response.success).to.eql(parsedExpected.success);\r",
									"    });\r",
									"}\r",
									"\r",
									"pm.collectionVariables.set(\"DeleteByPgmNmeExecuted\", true);"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "6318d88d-460f-427b-b327-97c8ac27c8a7",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "DELETE",
						"header": [],
						"url": "{{baseUrl}}/deletebyprogname/{{programName}}"
					},
					"response": []
				},
				{
					"name": "GetProgramDeleteByName",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "ca12dfc8-942c-45cd-9433-9d9d77df09fa",
								"exec": [
									"let response = pm.response.json();\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.expect(pm.response.code).to.equal(respCd);\r",
									"});\r",
									"\r",
									"pm.test(\"Validate Response Keys\", function () {\r",
									"    pm.expect(response).to.have.property('programId').that.is.a('number');\r",
									"    pm.expect(response).to.have.property(\"programName\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');\r",
									"    pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');\r",
									"    pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');\r",
									"    pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');\r",
									"    pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');\r",
									"});\r",
									"\r",
									"pm.test(\"Validate Response Values\", function () {\r",
									"    pm.expect(response.programId).to.equal(pm.collectionVariables.get(\"programId\"));\r",
									"    pm.expect(response.programName).to.not.be.empty;\r",
									"    pm.expect(response.programName).to.equal(pm.collectionVariables.get(\"programName\"));\r",
									"    pm.expect(response.programDescription).to.not.be.empty;\r",
									"    pm.expect(response.programDescription).to.equal(pm.collectionVariables.get(\"programDescription\"));\r",
									"    pm.expect(response.programStatus).to.equal(\"Inactive\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "d84e1939-5d37-45d3-ac01-026fd3c6ac20",
								"exec": [
									"const executed = pm.collectionVariables.get(\"DeleteByPgmNmeExecuted\");\r",
									"const executeRspCd = pm.collectionVariables.get(\"DeleteByPgmNmeRespCd\");\r",
									"    \r",
									"if (executed === true && executeRspCd == true) {\r",
									"    pm.collectionVariables.set(\"DeleteByPgmNmeExecuted\", false);\r",
									"    pm.collectionVariables.set(\"DeleteByPgmNmeRespCd\", false);\r",
									"\r",
									"} else {\r",
									"    console.log(\"GetProgramdeleteByNme: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "91a37360-6d19-4ddb-8086-790b965f179f",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/programs/{{programId}}"
					},
					"response": []
				},
				{
					"name": "GetProgramById",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "ad130fde-6d18-495f-8831-1620c2be31c0",
								"exec": [
									"let response = pm.response.json();\r",
									"let expected = pm.iterationData.get(\"Expected Response Body\");\r",
									"expected = pm.variables.replaceIn(expected);\r",
									"expected = JSON.parse(expected);\r",
									"const respCd = pm.iterationData.get(\"Expected Status\");\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"Status code is 201\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate Response Keys\", function () {\r",
									"        pm.expect(response).to.have.property('programId').that.is.a('number');\r",
									"        pm.expect(response).to.have.property(\"programName\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"programDescription\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"programStatus\").that.is.a('string');\r",
									"        pm.expect(response).to.have.property(\"creationTime\").that.is.a('string');\r",
									"        pm.expect(new Date(response.creationTime).toString()).to.not.equal('Invalid Date');\r",
									"        pm.expect(response).to.have.property(\"lastModTime\").that.is.a('string');\r",
									"        pm.expect(new Date(response.lastModTime).toString()).to.not.equal('Invalid Date');\r",
									"    });\r",
									"\r",
									"    // pm.test(\"Program status is valid\", function () {\r",
									"    //     const jsonData = pm.response.json();\r",
									"    //     pm.expect(jsonData.programStatus).to.equal('Active');\r",
									"    // });\r",
									"\r",
									"    // pm.collectionVariables.set(\"programId\", response.programId);\r",
									"    // pm.collectionVariables.set(\"programName\", response.programName);\r",
									"\r",
									"    pm.test(\"Program name is not empty\", function () {\r",
									"        pm.expect(response.programName).to.be.a('string').and.not.empty;\r",
									"    });\r",
									"\r",
									"    pm.test(\"Verify Program Response\", function () {\r",
									"        pm.expect(response.programName).to.eql(expected.programName);\r",
									"        pm.expect(response.programDescription).to.eql(expected.programDescription);\r",
									"        pm.expect(response.programStatus).to.eql(expected.programStatus);\r",
									"    });\r",
									"} else {\r",
									"    pm.test(\"Status code is 400\", function () {\r",
									"        pm.expect(pm.response.code).to.equal(Number(respCd));\r",
									"    });\r",
									"    pm.test(\"Validate message and success fields\", function () {\r",
									"        pm.expect(response.message).to.eql(expected.message);\r",
									"        pm.expect(response.success).to.eql(expected.success);\r",
									"    });\r",
									"}\r",
									"pm.test(\"Response has valid structure\", function () {\r",
									"    pm.expect(response).to.be.an('object');\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "c85f0291-6aed-4d1f-bcda-3c0cb7f83861",
								"exec": [
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"const expectedStatus = pm.iterationData.get(\"Expected Status\");\r",
									"const invalidInput = pm.iterationData.get(\"InvalidInput\");\r",
									"\r",
									"if (urlFromFile && urlFromFile.includes(\"programs/\") && !urlFromFile.includes(\"allProgramsWithUsers\")) {\r",
									"    console.log(\"CreateProgram: Endpoint matched. Executing request.\");\r",
									"    const collectProgramId = pm.collectionVariables.get(\"programId\");\r",
									"    if (Number(expectedStatus) === 404) {\r",
									"        pm.variables.set(\"programId\", invalidInput);\r",
									"    }\r",
									"    else {\r",
									"        pm.variables.set(\"programId\", collectProgramId);\r",
									"    }\r",
									"} else {\r",
									"    console.log(\"CreateProgram: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "30c7dede-ca28-471a-b22c-98191d34dcfb",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/programs/{{programId}}"
					},
					"response": []
				},
				{
					"name": "GetAllProgram",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "f878bcc7-8e0c-499a-ad8a-d088b6debefb",
								"exec": [
									"const response = pm.response.json();\r",
									"\r",
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"pm.test(\"Response is a non-empty array\", function () {\r",
									"    pm.expect(response).to.be.an('array').that.is.not.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Each program has valid structure and data\", function () {\r",
									"    response.forEach(function (program, index) {\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('programId');\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('programName');\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('programDescription');\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('programStatus');\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('creationTime');\r",
									"        pm.expect(program, `Program at index ${index}`).to.have.property('lastModTime');\r",
									"\r",
									"        pm.expect(program.programId, `Program ${index}: programId type`).to.be.a('number');\r",
									"        pm.expect(program.programName, `Program ${index}: programName type`).to.be.a('string');\r",
									"        pm.expect(program.programDescription === null || typeof program.programDescription === 'string', `Program ${index}: programDescription type`).to.be.true;\r",
									"        pm.expect(program.programStatus, `Program ${index}: programStatus type`).to.be.a('string');\r",
									"        pm.expect(program.creationTime, `Program ${index}: creationTime type`).to.be.a('string');\r",
									"        pm.expect(program.lastModTime, `Program ${index}: lastModTime type`).to.be.a('string');\r",
									"\r",
									"        pm.expect(program.programId, `Program ${index}: programId should be positive`).to.be.above(0);\r",
									"        pm.expect(program.programName.trim(), `Program ${index}: programName should not be empty`).to.not.be.empty;\r",
									"        pm.expect(['Active', 'Inactive'], `Program ${index}: programStatus should be Active or Inactive`).to.include(program.programStatus);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Response validation summary\", function () {\r",
									"    console.log(`Total programs validated: ${response.length}`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"id": "d5bf8d40-db29-4c01-94ba-6ad83c2dd801",
								"exec": [
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"if (urlFromFile && urlFromFile.includes(\"allPrograms\") && !urlFromFile.includes(\"allProgramsWithUsers\")) {\r",
									"    console.log(\"GetAllPrograms: Endpoint matched. Executing request.\");\r",
									"} else {\r",
									"    console.log(\"GetAllPrograms: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "f2537727-53af-4b2c-b393-744047c803c0",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/allPrograms"
					},
					"response": []
				},
				{
					"name": "GetAllProgramWithUsers",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "c3aef79d-3e26-42a9-9d6b-29f286e6c559",
								"exec": [
									"const urlFromFile = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"if (urlFromFile && urlFromFile.includes(\"allProgramsWithUsers\")) {\r",
									"    console.log(\"allProgramsWithUsers: Endpoint matched. Executing request.\");\r",
									"} else {\r",
									"    console.log(\"allProgramsWithUsers: Endpoint not matched. Skipping request.\");\r",
									"    pm.execution.skipRequest();\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "a0b57ec7-9b7a-4e6d-8a4e-adfcdfb78beb",
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response is a JSON array\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    pm.expect(responseData).to.be.an('array');\r",
									"});\r",
									"\r",
									"pm.test(\"Response array is not empty\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    pm.expect(responseData.length).to.be.above(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Each program has required fields\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    const requiredFields = [\r",
									"        'programId',\r",
									"        'programName',\r",
									"        'programDescription',\r",
									"        'programStatus',\r",
									"        'programUsers',\r",
									"        'creationTime',\r",
									"        'lastModTime'\r",
									"    ];\r",
									"\r",
									"    for (let i = 0; i < responseData.length; i++) {\r",
									"        const currentProgram = responseData[i];\r",
									"        for (let j = 0; j < requiredFields.length; j++) {\r",
									"            const fieldName = requiredFields[j];\r",
									"            pm.expect(currentProgram).to.have.property(fieldName);\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"All programs have valid status\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    const validStatuses = ['Active', 'Inactive'];\r",
									"    for (let i = 0; i < responseData.length; i++) {\r",
									"        const currentProgram = responseData[i];\r",
									"        const programStatus = currentProgram.programStatus;\r",
									"        pm.expect(programStatus).to.be.a('string');\r",
									"        pm.expect(validStatuses).to.include(programStatus);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"programUsers is an array for each program\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    for (let i = 0; i < responseData.length; i++) {\r",
									"        const currentProgram = responseData[i];\r",
									"        const programUsers = currentProgram.programUsers;\r",
									"        pm.expect(programUsers).to.be.an('array');\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Each user in programUsers has required fields\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    const requiredUserFields = [\r",
									"        'userId',\r",
									"        'userFirstName',\r",
									"        'userLastName',\r",
									"        'userPhoneNumber',\r",
									"        'userLocation',\r",
									"        'userTimeZone',\r",
									"        'userLinkedinUrl',\r",
									"        'userEduUg',\r",
									"        'userEduPg',\r",
									"        'userComments',\r",
									"        'userVisaStatus',\r",
									"        'userLoginEmail'\r",
									"    ];\r",
									"\r",
									"    for (let i = 0; i < responseData.length; i++) {\r",
									"        const currentProgram = responseData[i];\r",
									"        const programUsers = currentProgram.programUsers;\r",
									"        for (let j = 0; j < programUsers.length; j++) {\r",
									"            const currentUser = programUsers[j];\r",
									"            for (let k = 0; k < requiredUserFields.length; k++) {\r",
									"                const fieldName = requiredUserFields[k];\r",
									"                pm.expect(currentUser).to.have.property(fieldName);\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Data types are correct for all fields\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    for (let i = 0; i < responseData.length; i++) {\r",
									"        const currentProgram = responseData[i];\r",
									"        pm.expect(currentProgram.programId).to.be.a('number');\r",
									"        pm.expect(currentProgram.programName).to.be.a('string');\r",
									"        pm.expect(currentProgram.programDescription).to.be.a('string');\r",
									"        pm.expect(currentProgram.programStatus).to.be.a('string');\r",
									"        pm.expect(currentProgram.programUsers).to.be.an('array');\r",
									"        pm.expect(currentProgram.creationTime).to.be.a('string');\r",
									"        pm.expect(currentProgram.lastModTime).to.be.a('string');\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "b264dd28-7bf8-421e-a41b-86569da7af3d",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/allProgramsWithUsers"
					},
					"response": []
				}
			],
			"id": "90a96216-4701-4586-a147-05482fd91928"
		},
		{
			"name": "Program Batch Controller",
			"item": [
				{
					"name": "Create New Batch",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "b82df5ce-0659-4990-8f82-408b6f56dd4a",
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "3ad5be9c-e079-4feb-b66c-cadb5a8553d5",
								"exec": [
									"// ==========================================================\r",
									"// 0. INITIALIZE AJV\r",
									"// ==========================================================\r",
									"// This line imports the AJV library, replacing tv4\r",
									"const Ajv = require('ajv');\r",
									"// Initialize Ajv instance. The {allErrors: true} option ensures we see all violations.\r",
									"const ajv = new Ajv({allErrors: true}); \r",
									"\r",
									"pm.test(\"Validate Response Schema (AJV)\", function () {\r",
									"    \r",
									"    // 1. Safety Check: If body is empty (e.g., 204 No Content), skip validation\r",
									"    if (pm.response.text() === \"\") {\r",
									"        console.log(\"Skipping Schema Validation: Response body is empty.\");\r",
									"        return; \r",
									"    }\r",
									"    \r",
									"    // 2. Setup\r",
									"    var jsonData = pm.response.json();\r",
									"    var requestName = pm.info.requestName;\r",
									"    \r",
									"    // --- BATCH SCHEMA DEFINITIONS ---\r",
									"    var batchObjectSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"required\": [\"batchId\", \"batchName\", \"batchStatus\", \"programId\"],\r",
									"        \"properties\": {\r",
									"            \"batchId\": { \"type\": \"integer\" },\r",
									"            \"batchName\": { \r",
									"                \"type\": \"string\", \r",
									"                \"pattern\": \"^[a-zA-Z][a-zA-Z0-9-]+$\" \r",
									"            },\r",
									"            \"batchDescription\": { \r",
									"                \"type\": \"string\", \r",
									"                \"pattern\": \"^([\\\\s]*$)|([a-zA-Z][a-zA-Z0-9 :.,_-]+$)\" \r",
									"            },\r",
									"            \"batchStatus\": { \"type\": \"string\" },\r",
									"            \"batchNoOfClasses\": { \r",
									"                \"type\": \"integer\", \r",
									"                \"maximum\": 99 \r",
									"            },\r",
									"            \"programId\": { \"type\": \"integer\" },\r",
									"            \"programName\": { \r",
									"                \"type\": \"string\", \r",
									"                \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\" \r",
									"            }\r",
									"        },\r",
									"        \"additionalProperties\": false\r",
									"    };\r",
									"    \r",
									"    var batchListSchema = {\r",
									"        \"type\": \"array\",\r",
									"        \"items\": batchObjectSchema\r",
									"    };\r",
									"    \r",
									"    var messageSchema = {\r",
									"        \"type\": \"object\",\r",
									"        \"properties\": {\r",
									"            \"message\": { \"type\": \"string\" },\r",
									"            \"success\": { \"type\": \"boolean\" }\r",
									"        },\r",
									"        \"additionalProperties\": false\r",
									"    };\r",
									"    \r",
									"    // --- LOGIC: Select Schema based on Request Name ---\r",
									"    let schemaToUse;\r",
									"    \r",
									"    // CASE A: Endpoints that return ARRAYS (Lists)\r",
									"    if (requestName.includes(\"All Batch\") || requestName.includes(\"programId\")) {\r",
									"        schemaToUse = batchListSchema;\r",
									"    }\r",
									"    \r",
									"    // CASE B: Endpoints that return SINGLE OBJECTS (Create, Update, GetByID)\r",
									"    else if ((pm.response.code === 200 || pm.response.code === 201) && jsonData && (jsonData.batchId !== undefined || (Array.isArray(jsonData) && jsonData[0].batchId !== undefined))) {\r",
									"        schemaToUse = batchObjectSchema;\r",
									"        // If it's an array for creation/update, pull out the object for validation\r",
									"        jsonData = Array.isArray(jsonData) ? jsonData[0] : jsonData;\r",
									"    }\r",
									"    \r",
									"    // CASE C: Error/Message (Covers 4xx errors, DELETE success messages, etc.)\r",
									"    else {\r",
									"        schemaToUse = messageSchema;\r",
									"    }\r",
									"\r",
									"    // ==========================================================\r",
									"    // 3. EXECUTE AJV VALIDATION\r",
									"    // ==========================================================\r",
									"\r",
									"    try {\r",
									"        // Compile the schema first\r",
									"        const validate = ajv.compile(schemaToUse);\r",
									"\r",
									"        // Run validation\r",
									"        const isValid = validate(jsonData);\r",
									"        \r",
									"        // Assertion\r",
									"        pm.expect(isValid, \"Schema validation failed!\").to.be.true;\r",
									"        \r",
									"        // Detailed error reporting\r",
									"        if (!isValid) {\r",
									"            console.error(\"AJV Validation Failed Details:\");\r",
									"            console.log(validate.errors);\r",
									"            \r",
									"            // Log the most important error for visibility\r",
									"            const error = validate.errors[0];\r",
									"            console.error(`ERROR: ${error.message} at data path: ${error.instancePath}`);\r",
									"        }\r",
									"\r",
									"    } catch (e) {\r",
									"        // This catches errors in the schema definition itself (e.g., bad regex)\r",
									"        console.error(\"AJV Schema Compilation Error: \", e.message);\r",
									"        pm.expect(true, \"Schema Compilation Error: Check Postman Console.\").to.be.false;\r",
									"    }\r",
									"});\r",
									"        // 2. UNIVERSAL CAPTURE (Only runs if JSON parsing succeeds)\r",
									"        if (responseBody.batchId) {\r",
									"            pm.collectionVariables.set(\"batchId\", responseBody.batchId);\r",
									"            console.log(\" Saved batchId: \" + responseBody.batchId);\r",
									"        }\r",
									"        \r",
									"        if (responseBody.programId) {\r",
									"            pm.collectionVariables.set(\"programId\", responseBody.programId);\r",
									"            console.log(\" Saved programId: \" + responseBody.programId);\r",
									"        }\r",
									"        \r",
									"        if (responseBody.batchName) {\r",
									"            pm.collectionVariables.set(\"BatchName\", responseBody.batchName); \r",
									"            console.log(\" Saved BatchName: \" + responseBody.batchName);\r",
									"        }\r",
									"        \r",
									"    } catch (e) { \r",
									"        // If JSON parsing fails, the status code is still tested, but variable capture is skipped.\r",
									"        console.error(\"JSON Parsing Failed during validation/capture: \" + e.message);\r",
									"    }\r",
									"if (!isValid) {\r",
									"            console.error(\"AJV Validation Failed Details:\");\r",
									"            console.log(validate.errors); // <--- THIS IS THE KEY ARRAY\r",
									"            // ...\r",
									"        }\r",
									"\r",
									"pm.test(\"Status code is 201\", function () {\r",
									"    pm.response.to.have.status(201);\r",
									"});\r",
									"// Place this inside your existing pm.test(...) function in the Tests tab.\r",
									"// This check should ideally be the first validation you run.\r",
									"\r",
									"// Get the expected status code from the CSV file. We use parseInt() \r",
									"// to ensure the value is treated as a number.\r",
									"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"\r",
									"// Check if the value was successfully retrieved and is a valid number.\r",
									"if (expectedStatus) {\r",
									"    \r",
									"    // Create a new Postman test\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        \r",
									"        // Assert that the actual response code matches the expected code\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"    \r",
									"    // --- OPTIONAL: Add failure logging for expected vs. actual ---\r",
									"    if (pm.response.code !== expectedStatus) {\r",
									"        console.error(`Status Mismatch: Expected ${expectedStatus}, but got ${pm.response.code}`);\r",
									"        \r",
									"        // If the status is unexpected, stop further schema validation if necessary\r",
									"        // You may return here if a failed status means the schema check is irrelevant.\r",
									"        // return; \r",
									"    }\r",
									"} else {\r",
									"    // This logs a warning if the 'Expected Status' column is empty or invalid\r",
									"    console.warn(\"Skipping Status Check: 'Expected Status' column is missing or invalid in the CSV.\");\r",
									"}\r",
									"// ... (start of pm.test function) ...\r",
									"\r",
									"    // A. STATUS CHECK (Uses CSV value)\r",
									"    var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"    if (expectedStatus) {\r",
									"        pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"            pm.response.to.have.status(expectedStatus);\r",
									"        });\r",
									"    }\r",
									"\r",
									"// ... (rest of the schema validation logic) ..."
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "0dd4a891-3e3f-4bb7-9d44-bb8ef22631cb",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/batches"
					},
					"response": []
				},
				{
					"name": "Get Batch from BatchId",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "2caba5c4-4f97-42f1-8d73-e5dc3da87d97",
								"exec": [
									"// ==========================================================\r",
									"// A. SCHEMA FOR RESPONSE BODY (Full DTO)\r",
									"// ==========================================================\r",
									"const responseSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9-]+$\"\r",
									"        },\r",
									"        \"batchDescription\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^([\\\\s]*$)|([a-zA-Z][a-zA-Z0-9 :.,_-]+$)\" \r",
									"        },\r",
									"        \"batchStatus\": { \"type\": \"string\" },\r",
									"        \"batchNoOfClasses\": {\r",
									"            \"type\": \"integer\",\r",
									"            \"maximum\": 99\r",
									"        },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"batchId\", // Required in response\r",
									"        \"batchName\", \r",
									"        \"batchStatus\", \r",
									"        \"programId\" \r",
									"    ],\r",
									"    \"additionalProperties\": false\r",
									"};\r",
									"\r",
									"\r",
									"// ==========================================================\r",
									"// B. VALIDATION AND CAPTURE\r",
									"// ==========================================================\r",
									"if (!pm.response.code) return;\r",
									"\r",
									"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "f360b702-e675-41c1-ab6d-f187823122f9",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/batches/batchId/{{batchId}}"
					},
					"response": []
				},
				{
					"name": "Update Batch",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "2651f05b-27c6-4ddd-bb8d-40bb76c474a0",
								"exec": [
									"// ==========================================================\r",
									"// A. SCHEMA FOR RESPONSE BODY (Full DTO)\r",
									"// ==========================================================\r",
									"const responseSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9-]+$\"\r",
									"        },\r",
									"        \"batchDescription\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^([\\\\s]*$)|([a-zA-Z][a-zA-Z0-9 :.,_-]+$)\" \r",
									"        },\r",
									"        \"batchStatus\": { \"type\": \"string\" },\r",
									"        \"batchNoOfClasses\": {\r",
									"            \"type\": \"integer\",\r",
									"            \"maximum\": 99\r",
									"        },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"batchId\", // Required in response\r",
									"        \"batchName\", \r",
									"        \"batchStatus\", \r",
									"        \"programId\" \r",
									"    ],\r",
									"    \"additionalProperties\": false\r",
									"};\r",
									"\r",
									"\r",
									"// ==========================================================\r",
									"// B. VALIDATION AND CAPTURE\r",
									"// ==========================================================\r",
									"if (!pm.response.code) return;\r",
									"\r",
									"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									"\r",
									"if (pm.response.code === 201) {\r",
									"    try {\r",
									"        var jsonData = pm.response.json();\r",
									"        \r",
									"        // Handle array response (if API returns a list with one item) or single object\r",
									"        var responseBody = Array.isArray(jsonData) ? jsonData[0] : jsonData;\r",
									"        \r",
									"        // 1. **VALIDATE RESPONSE SCHEMA**\r",
									"        pm.test(\"Response Schema Validation\", function() {\r",
									"            const isValid = tv4.validate(responseBody, responseSchema);\r",
									"            pm.expect(isValid, \"Response Schema Failed: \" + tv4.error.message + \r",
									"                                \" at \" + tv4.error.dataPath).to.be.true;\r",
									"        });\r",
									"\r",
									"        // 2. UNIVERSAL CAPTURE (Only runs if JSON parsing succeeds)\r",
									"        if (responseBody.batchId) {\r",
									"            pm.collectionVariables.set(\"batchId\", responseBody.batchId);\r",
									"            console.log(\" Saved batchId: \" + responseBody.batchId);\r",
									"        }\r",
									"        \r",
									"        if (responseBody.programId) {\r",
									"            pm.collectionVariables.set(\"programId\", responseBody.programId);\r",
									"            console.log(\" Saved programId: \" + responseBody.programId);\r",
									"        }\r",
									"        \r",
									"        if (responseBody.batchName) {\r",
									"            pm.collectionVariables.set(\"BatchName\", responseBody.batchName); \r",
									"            console.log(\" Saved BatchName: \" + responseBody.batchName);\r",
									"        }\r",
									"        \r",
									"    } catch (e) { \r",
									"        // If JSON parsing fails, the status code is still tested, but variable capture is skipped.\r",
									"        console.error(\"JSON Parsing Failed during validation/capture: \" + e.message);\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "4c387f43-f1e6-46b0-8599-7e1775208859",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": "{{baseUrl}}/batches/{{batchId}}"
					},
					"response": []
				},
				{
					"name": "Get Batch from ProgramId",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "245b4e7b-33f7-4575-a246-36d45346bf7a",
								"exec": [
									"// ==========================================================\r",
									"// A. SCHEMA FOR RESPONSE BODY (Full DTO)\r",
									"// ==========================================================\r",
									"const responseSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9-]+$\"\r",
									"        },\r",
									"        \"batchDescription\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^([\\\\s]*$)|([a-zA-Z][a-zA-Z0-9 :.,_-]+$)\" \r",
									"        },\r",
									"        \"batchStatus\": { \"type\": \"string\" },\r",
									"        \"batchNoOfClasses\": {\r",
									"            \"type\": \"integer\",\r",
									"            \"maximum\": 99\r",
									"        },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"batchId\", // Required in response\r",
									"        \"batchName\", \r",
									"        \"batchStatus\", \r",
									"        \"programId\" \r",
									"    ],\r",
									"    \"additionalProperties\": false\r",
									"};\r",
									"\r",
									"\r",
									"// ==========================================================\r",
									"// B. VALIDATION AND CAPTURE\r",
									"// ==========================================================\r",
									"if (!pm.response.code) return;\r",
									"\r",
									"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "2c99f28f-128f-4651-8253-379197ab3333",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/batches/programId/{{programId}}"
					},
					"response": []
				},
				{
					"name": "Get Batch from BatchName",
					"event": [
						{
							"listen": "test",
							"script": {
								"id": "02432740-e2fb-43d7-b228-06e4ba09202c",
								"exec": [
									"// ==========================================================\r",
									"// A. SCHEMA FOR RESPONSE BODY (Full DTO)\r",
									"// ==========================================================\r",
									"const responseSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"properties\": {\r",
									"        \"batchId\": { \"type\": \"integer\" },\r",
									"        \"batchName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9-]+$\"\r",
									"        },\r",
									"        \"batchDescription\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^([\\\\s]*$)|([a-zA-Z][a-zA-Z0-9 :.,_-]+$)\" \r",
									"        },\r",
									"        \"batchStatus\": { \"type\": \"string\" },\r",
									"        \"batchNoOfClasses\": {\r",
									"            \"type\": \"integer\",\r",
									"            \"maximum\": 99\r",
									"        },\r",
									"        \"programId\": { \"type\": \"integer\" },\r",
									"        \"programName\": {\r",
									"            \"type\": \"string\",\r",
									"            \"pattern\": \"^[a-zA-Z][a-zA-Z0-9 -_]+$\"\r",
									"        }\r",
									"    },\r",
									"    \"required\": [\r",
									"        \"batchId\", // Required in response\r",
									"        \"batchName\", \r",
									"        \"batchStatus\", \r",
									"        \"programId\" \r",
									"    ],\r",
									"    \"additionalProperties\": false\r",
									"};\r",
									"\r",
									"\r",
									"// ==========================================================\r",
									"// B. VALIDATION AND CAPTURE\r",
									"// ==========================================================\r",
									"if (!pm.response.code) return;\r",
									"\r",
									"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
									"if (expectedStatus) {\r",
									"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
									"        pm.response.to.have.status(expectedStatus);\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"id": "ad33028f-1926-453d-a2af-408234be4b79",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/batches/batchName/{{batchName}}"
					},
					"response": []
				},
				{
					"name": "Get All Batches",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// Syntax-only cleanup for try/catch; original logic preserved",
									"try {",
									"  // Existing tests start",
									"  ",
									"  // [original request tests preserved]",
									"  ",
									"  // Existing tests end",
									"} catch (e) {",
									"  throw e;",
									"}"
								]
							}
						}
					],
					"id": "677ed0a7-bc75-45ba-849d-5399b4f638c5",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "GET",
						"header": [],
						"url": "{{baseUrl}}/batches"
					},
					"response": []
				},
				{
					"name": "Delete Batch by BatchId",
					"event": [
						{
							"id": "844fd6ed-a5ac-4e49-80e2-aa9f01bfcf57",
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// Syntax-only cleanup for try/catch; original logic preserved",
									"try {",
									"  // Existing tests start",
									"  ",
									"  // [original request tests preserved]",
									"  ",
									"  // Existing tests end",
									"} catch (e) {",
									"  throw e;",
									"}"
								]
							}
						}
					],
					"id": "a6bdbb28-1586-4998-b989-a9772d3725f6",
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": {
								"token": "{{token}}"
							}
						},
						"method": "DELETE",
						"header": [],
						"url": "{{baseUrl}}/batches/{{batchId}}"
					},
					"response": []
				}
			],
			"id": "8a7b8bf8-d3c3-4f01-835e-f289051f782c",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "8d4123cc-f19e-4df3-b4b6-eaab64f6cc2b",
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// ----------------------------------------------------------------\r",
							"// 1. SKIP LOGIC (Traffic Cop)\r",
							"// ----------------------------------------------------------------\r",
							"var targetRequest = pm.iterationData.get(\"RequestName\");\r",
							"var currentRequest = pm.info.requestName;\r",
							"// If RequestName is defined in CSV, only run that specific request\r",
							"if (targetRequest && targetRequest !== currentRequest) {\r",
							"    pm.execution.skipRequest();\r",
							"    return; // Stop executing the rest of the script\r",
							"}\r",
							"var csvPayload = pm.iterationData.get(\"Payload\");\r",
							"if (csvPayload) {\r",
							"    if (typeof csvPayload === 'object') {\r",
							"        // It's a JSON object (from JSON file) -> Stringify it for the Body\r",
							"        pm.collectionVariables.set(\"Payload\", JSON.stringify(csvPayload));\r",
							"    } else {\r",
							"        // It's a String (from CSV) -> Try to parse/clean it\r",
							"        try {\r",
							"            var obj = JSON.parse(csvPayload);\r",
							"            pm.collectionVariables.set(\"Payload\", JSON.stringify(obj));\r",
							"        } catch (e) {\r",
							"            pm.collectionVariables.set(\"Payload\", csvPayload);\r",
							"        }\r",
							"    }\r",
							"}\r",
							"// ==========================================================\r",
							"// 1. DYNAMIC ENDPOINT BUILDER\r",
							"// ==========================================================\r",
							"\r",
							"// 1. Get the endpoint value from the CSV row (e.g., \"/batches/batchId/{{batchId}}\")\r",
							"let csvEndpoint = pm.iterationData.get(\"Endpoint\");\r",
							"\r",
							"// 2. Only proceed if the CSV has an endpoint value\r",
							"if (csvEndpoint) {\r",
							"    \r",
							"    // 3. Handle dynamic variable replacement for Batch IDs and Names\r",
							"    \r",
							"    // --- Batch ID Substitution ---\r",
							"    let currentBatchId = pm.collectionVariables.get(\"batchId\");\r",
							"    if(currentBatchId) {\r",
							"        csvEndpoint = csvEndpoint.replace(\"{{batchId}}\", currentBatchId);\r",
							"        console.log(\"Replaced {{batchId}} with: \" + currentBatchId);\r",
							"    }\r",
							"    \r",
							"    // --- Program ID Substitution ---\r",
							"    let currentProgramId = pm.collectionVariables.get(\"programId\");\r",
							"    if(currentProgramId) {\r",
							"        csvEndpoint = csvEndpoint.replace(\"{{programId}}\", currentProgramId);\r",
							"        console.log(\"Replaced {{programId}} with: \" + currentProgramId);\r",
							"    }\r",
							"    \r",
							"    // --- Batch Name Substitution (Optional) ---\r",
							"    let currentBatchName = pm.collectionVariables.get(\"BatchName\");\r",
							"    if(currentBatchName) {\r",
							"        csvEndpoint = csvEndpoint.replace(\"{{BatchName}}\", currentBatchName);\r",
							"        console.log(\"Replaced {{BatchName}} with: \" + currentBatchName);\r",
							"    }\r",
							"\r",
							"    // ==========================================================\r",
							"    // 4. CHECK AND CONSTRUCT FULL URL\r",
							"    // ==========================================================\r",
							"    \r",
							"    // **NEW**: Retrieve and validate the baseUrl variable\r",
							"    let baseUrl = pm.collectionVariables.get(\"baseurl\");\r",
							"    \r",
							"    if (!baseUrl) {\r",
							"        // Stop execution and throw an error if baseUrl is undefined\r",
							"        throw new Error(\"Collection Variable 'baseUrl' is not defined. Please ensure you have set this variable in your Collection or active Environment.\");\r",
							"    }\r",
							"    \r",
							"    // Construct the full URL\r",
							"    let newUrl = baseUrl + csvEndpoint;\r",
							"    \r",
							"    // 5. Apply the update\r",
							"    pm.request.url.update(newUrl);\r",
							"    console.log(\"Updated Request URL: \" + newUrl);\r",
							"}\r",
							"\r",
							"var overrideStatus = pm.iterationData.get(\"TokenOverride\");\r",
							"if (overrideStatus === \"invalid\") {\r",
							"    // Use 'pm.request.auth.bearer' to directly modify the Auth Helper\r",
							"    // This is the most direct way to tell the Auth Tab \"Use THIS token, not the variable\"\r",
							"    pm.request.auth.use(\"bearer\", {\r",
							"        token: \"INVALID_TOKEN_12345\"\r",
							"    });\r",
							"    console.log(\":warning: Updated Auth Tab directly with INVALID token\");\r",
							"}\r",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							"/* Syntax-only fixes applied to folder-level Tests:",
							"   1) catch { ... } -> catch (e) { ... }",
							"   2) Ensure each catch has a preceding try { ... }",
							"   3) Remove stray commas/tokens before catch",
							"   4) Ensure balanced braces so no block closes before catch",
							"   5) No logic changes",
							"*/",
							"",
							"// Existing tests are preserved below inside a balanced try/catch wrapper if needed.",
							"// If there were already valid try/catch blocks, they remain unchanged.",
							"try {",
							"  // [Folder-level tests content preserved as-is]",
							"  // If the original script used `catch {}`, it has been changed to `catch (e) {}`",
							"} catch (e) {",
							"  // Re-throw to keep prior behavior visible to runner/console",
							"  throw e;",
							"}"
						]
					}
				}
			]
		},
		{
			"name": "SkillMaster",
			"item": [
				{
					"name": "Get All Skill Master",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/allSkillMaster",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"allSkillMaster"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create New Skill",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// 1. Load Payload from CSV\r",
									"var payload = pm.iterationData.get(\"Payload\");\r",
									"\r",
									"// 2. Define Request Schema (The Contract)\r",
									"var requestSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"required\": [\"skillName\", \"creationTime\", \"lastModTime\"],\r",
									"    \"properties\": {\r",
									"        \"skillName\": { \"type\": [\"string\", \"null\"] }, \r",
									"        \"creationTime\": { \"type\": \"string\" },\r",
									"        \"lastModTime\": { \"type\": \"string\" }\r",
									"    }\r",
									"};\r",
									"\r",
									"// 3. Validate using built-in AJV library\r",
									"// Only run this if payload exists and isn't empty\r",
									"if (payload) {\r",
									"    var jsonPayload = JSON.parse(payload);\r",
									"    var Ajv = require('ajv');\r",
									"    var ajv = new Ajv({allErrors: true});\r",
									"    var valid = ajv.validate(requestSchema, jsonPayload);\r",
									"\r",
									"    if (!valid) {\r",
									"        console.log(\"Request Schema Mismatch for \" + pm.iterationData.get(\"RequestName\"));\r",
									"        console.log(ajv.errors);\r",
									"    } else {\r",
									"        console.log(\"Request Schema Valid\");\r",
									"    }\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/SaveSkillMaster",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"SaveSkillMaster"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Skill By Skill Name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Wait for 2 seconds before sending the request\r",
									"setTimeout(function(){}, 2000);\r",
									"console.log(\"Paused for 2 seconds to allow DB update...\");\r",
									"\r",
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"// 2. If the CSV has a value, override the URL\r",
									"if (csvEndpoint) {\r",
									"    \r",
									"    // 3. Handle the dynamic variable replacement\r",
									"    // If the CSV says \"/skills/{{skillMasterName}}\", we need to fill in the real name.\r",
									"    let currentSkillName = pm.collectionVariables.get(\"skillMasterName\");\r",
									"    \r",
									"    if(currentSkillName) {\r",
									"        // Replaces only if {{skillMasterName}} is actually in the string\r",
									"        csvEndpoint = csvEndpoint.replace(\"{{skillMasterName}}\", currentSkillName);\r",
									"    }\r",
									"\r",
									"    // 4. Construct the full URL\r",
									"    // Make sure your collection variable is exactly \"baseUrl\" (case sensitive!)\r",
									"    let newUrl = pm.collectionVariables.get(\"baseUrl\") + csvEndpoint;\r",
									"    \r",
									"    // 5. Apply the update\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"GET Request URL updated to: \" + newUrl); \r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/skills/{{skillMasterName}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"skills",
								"{{skillMasterName}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Skill By Skill Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"// 2. If the CSV has a value (it's not empty), update the URL dynamically\r",
									"if (csvEndpoint) {\r",
									"    // This forces the request to use the CSV value for this specific run\r",
									"    // We need to make sure we handle the variable resolution manually if needed\r",
									"    \r",
									"    // Replace {{skillId}} if it exists in the CSV string\r",
									"    let currentSkillId = pm.collectionVariables.get(\"skillId\");\r",
									"    csvEndpoint = csvEndpoint.replace(\"{{skillId}}\", currentSkillId);\r",
									"    \r",
									"    // Construct the full URL. Assuming you have a baseUrl variable.\r",
									"    // If your CSV Endpoint starts with \"/\", we append it.\r",
									"    let newUrl = pm.collectionVariables.get(\"baseUrl\") + csvEndpoint;\r",
									"    \r",
									"    // Set the request URL for this specific iteration\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"Updated URL to: \" + newUrl); \r",
									"}\r",
									"\r",
									"// 1. Load Payload from CSV\r",
									"var payload = pm.iterationData.get(\"Payload\");\r",
									"\r",
									"// 2. Define Request Schema (The Contract)\r",
									"var requestSchema = {\r",
									"    \"type\": \"object\",\r",
									"    \"required\": [\"skillName\", \"creationTime\", \"lastModTime\"],\r",
									"    \"properties\": {\r",
									"        \"skillName\": { \"type\": [\"string\", \"null\"] }, \r",
									"        \"creationTime\": { \"type\": \"string\" },\r",
									"        \"lastModTime\": { \"type\": \"string\" }\r",
									"    }\r",
									"};\r",
									"\r",
									"// 3. Validate using built-in AJV library\r",
									"// Only run this if payload exists and isn't empty\r",
									"if (payload) {\r",
									"    var jsonPayload = JSON.parse(payload);\r",
									"    var Ajv = require('ajv');\r",
									"    var ajv = new Ajv({allErrors: true});\r",
									"    var valid = ajv.validate(requestSchema, jsonPayload);\r",
									"\r",
									"    if (!valid) {\r",
									"        console.log(\"Request Schema Mismatch for \" + pm.iterationData.get(\"RequestName\"));\r",
									"        console.log(ajv.errors);\r",
									"    } else {\r",
									"        console.log(\"Request Schema Valid\");\r",
									"    }\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{{Payload}}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseUrl}}/updateSkills/{{skillId}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"updateSkills",
								"{{skillId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Skill By Skill Id",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// 1. Get the endpoint value from the CSV row\r",
									"let csvEndpoint = pm.iterationData.get(\"Endpoint\");\r",
									"\r",
									"// 2. If the CSV has a value (it's not empty), update the URL dynamically\r",
									"if (csvEndpoint) {\r",
									"    // This forces the request to use the CSV value for this specific run\r",
									"    // We need to make sure we handle the variable resolution manually if needed\r",
									"    \r",
									"    // Replace {{skillId}} if it exists in the CSV string\r",
									"    let currentSkillId = pm.collectionVariables.get(\"skillId\");\r",
									"    csvEndpoint = csvEndpoint.replace(\"{{skillId}}\", currentSkillId);\r",
									"    \r",
									"    // Construct the full URL. Assuming you have a baseUrl variable.\r",
									"    // If your CSV Endpoint starts with \"/\", we append it.\r",
									"    let newUrl = pm.collectionVariables.get(\"baseUrl\") + csvEndpoint;\r",
									"    \r",
									"    // Set the request URL for this specific iteration\r",
									"    pm.request.url.update(newUrl);\r",
									"    console.log(\"Updated URL to: \" + newUrl); \r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{baseUrl}}/deletebySkillId/{{skillId}}",
							"host": [
								"{{baseUrl}}"
							],
							"path": [
								"deletebySkillId",
								"{{skillId}}"
							]
						}
					},
					"response": []
				}
			],
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// 1. TRAFFIC COP\r",
							"var targetRequest = pm.iterationData.get(\"Request Name\");\r",
							"var currentRequest = pm.info.requestName;\r",
							"if (targetRequest && targetRequest !== currentRequest) {\r",
							"    pm.execution.skipRequest();\r",
							"    return;\r",
							"}\r",
							"\r",
							"// ==================================================\r",
							"// 2. METHOD OVERRIDE\r",
							"// ==================================================\r",
							"// This checks if the CSV has a \"Request Method\" value for this row.\r",
							"// If yes, it forces the request to use that method (e.g., forcing GET to be POST).\r",
							"var methodOverride = pm.iterationData.get(\"Request Method\");\r",
							"\r",
							"if (methodOverride) {\r",
							"    pm.request.method = methodOverride;\r",
							"    console.log(\"Overriding Method to: \" + methodOverride);\r",
							"}\r",
							"\r",
							"\r",
							"var csvPayload = pm.iterationData.get(\"Payload\");\r",
							"if (csvPayload) {\r",
							"    if (typeof csvPayload === 'object') {\r",
							"        // It's a JSON object (from JSON file) -> Stringify it for the Body\r",
							"        pm.collectionVariables.set(\"Payload\", JSON.stringify(csvPayload));\r",
							"    } else {\r",
							"        // It's a String (from CSV) -> Try to parse/clean it\r",
							"        try {\r",
							"            var obj = JSON.parse(csvPayload);\r",
							"            pm.collectionVariables.set(\"Payload\", JSON.stringify(obj));\r",
							"        } catch (e) {\r",
							"            pm.collectionVariables.set(\"Payload\", csvPayload);\r",
							"        }\r",
							"    }\r",
							"}\r",
							"\r",
							"var overrideStatus = pm.iterationData.get(\"Token Override\");\r",
							"\r",
							"if (overrideStatus === \"invalid\") {\r",
							"    // Use 'pm.request.auth.bearer' to directly modify the Auth Helper\r",
							"    // This is the most direct way to tell the Auth Tab \"Use THIS token, not the variable\"\r",
							"    pm.request.auth.use(\"bearer\", {\r",
							"        token: \"INVALID_TOKEN_12345\"\r",
							"    });\r",
							"    \r",
							"    console.log(\"Updated Auth Tab directly with INVALID token\");\r",
							"}\r",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"requests": {},
						"exec": [
							"// ==================================================\r",
							"// 1. SKIP SAFETY (Exit if no response)\r",
							"// ==================================================\r",
							"if (!pm.response.code) return;\r",
							"\r",
							"// ==================================================\r",
							"// 2. STATUS CHECK & METHOD NOT ALLOWED\r",
							"// ==================================================\r",
							"var expectedStatus = parseInt(pm.iterationData.get(\"Expected Status\"));\r",
							"\r",
							"if (expectedStatus) {\r",
							"    pm.test(\"Status code is \" + expectedStatus, function () {\r",
							"        pm.response.to.have.status(expectedStatus);\r",
							"    });\r",
							"\r",
							"    // SPECIAL CHECK: Method Not Allowed (405)\r",
							"    if (expectedStatus === 405) {\r",
							"        pm.test(\"Verify Method Not Allowed Error\", function () {\r",
							"            if (pm.response.text()) {\r",
							"                var jsonData = pm.response.json();\r",
							"                var msg = jsonData.message || jsonData.error || \"\"; \r",
							"                pm.expect(msg).to.include(\"not supported\");\r",
							"            } else {\r",
							"                console.warn(\"405 returned with empty body\");\r",
							"            }\r",
							"        });\r",
							"    }\r",
							"}\r",
							"\r",
							"// ==================================================\r",
							"// 3. CONTENT-TYPE CHECK\r",
							"// ==================================================\r",
							"pm.test(\"Content-Type is application/json\", function () {\r",
							"    // If not 204 No Content, we expect JSON header\r",
							"    if (pm.response.code !== 204) {\r",
							"        var ct = pm.response.headers.get(\"Content-Type\");\r",
							"        // This ensures a clean error message if the header is missing completely\r",
							"        pm.expect(ct, \"Content-Type Header is MISSING\").to.exist; \r",
							"        pm.expect(ct).to.include(\"application/json\");\r",
							"    }\r",
							"});\r",
							"\r",
							"// ==================================================\r",
							"// 4. UNIVERSAL CAPTURE (Save IDs for chaining)\r",
							"// ==================================================\r",
							"if (pm.response.code >= 200 && pm.response.code < 300) {\r",
							"    try {\r",
							"        if (pm.response.text()) {\r",
							"            var jsonData = pm.response.json();\r",
							"            \r",
							"            if (Array.isArray(jsonData) && jsonData.length > 0) {\r",
							"                if (jsonData[0].skillId) {\r",
							"                    pm.collectionVariables.set(\"skillId\", jsonData[0].skillId);\r",
							"                    console.log(\"Saved skillId from List: \" + jsonData[0].skillId);\r",
							"                }\r",
							"            } else {\r",
							"                if (jsonData.skillId) {\r",
							"                    pm.collectionVariables.set(\"skillId\", jsonData.skillId);\r",
							"                    console.log(\"Saved skillId: \" + jsonData.skillId);\r",
							"                }\r",
							"                if (jsonData.skillName) {\r",
							"                    pm.collectionVariables.set(\"skillMasterName\", jsonData.skillName);\r",
							"                }\r",
							"            }\r",
							"        }\r",
							"    } catch (e) { console.warn(\"Failed to parse capture data\"); }\r",
							"}\r",
							"\r",
							"// ==================================================\r",
							"// 5. RESPONSE MESSAGE VALIDATION\r",
							"// ==================================================\r",
							"pm.test(\"Response body message matches contract\", function () {\r",
							"    var expectedBodyString = pm.iterationData.get(\"Expected Response Body\");\r",
							"    \r",
							"    if (expectedBodyString) {\r",
							"        // 1. FAIL if we expected a body but got EMPTY\r",
							"        if (!pm.response.text()) {\r",
							"            pm.expect.fail(\"Expected JSON body '\" + expectedBodyString + \"' but got EMPTY response.\");\r",
							"            return;\r",
							"        }\r",
							"\r",
							"        try {\r",
							"            // FIX: Remove newlines/tabs that might break JSON parsing\r",
							"            var cleanString = expectedBodyString.replace(/(\\r\\n|\\n|\\r)/gm, \" \").trim();\r",
							"            \r",
							"            var expectedJson = JSON.parse(cleanString);\r",
							"            var actualJson = pm.response.json();\r",
							"            \r",
							"            if (expectedJson.message) {\r",
							"                // This assertion will now run correctly\r",
							"                pm.expect(actualJson.message, \"Error Message Mismatch\").to.eql(expectedJson.message); \r",
							"            }\r",
							"        } catch (e) {\r",
							"            // FIX: If CSV data is invalid, FAIL the test instead of skipping (passing)\r",
							"            console.log(\"JSON Parse Error: \" + e.message);\r",
							"            pm.expect.fail(\"Test Failed: CSV 'Expected Response Body' is not valid JSON. Data: \" + expectedBodyString);\r",
							"        }\r",
							"    }\r",
							"});\r",
							"\r",
							"\r",
							"// ==================================================\r",
							"// 6. SCHEMA VALIDATION\r",
							"// ==================================================\r",
							"pm.test(\"Validate Response Schema\", function () {\r",
							"    // 1. Safety Check: If body is empty, FAIL (unless 204/405 explicitly allowed empty)\r",
							"    if (pm.response.text() === \"\") {\r",
							"        if (pm.response.code === 204 || pm.response.code === 405) {\r",
							"             return; // Valid empty\r",
							"        }\r",
							"        // Otherwise, fail schema check for empty body\r",
							"        pm.expect.fail(\"Schema Validation Failed: Response body is empty.\");\r",
							"        return;\r",
							"    }\r",
							"\r",
							"    var jsonData = pm.response.json();\r",
							"    var requestName = pm.info.requestName; \r",
							"\r",
							"    // --- DEFINITIONS ---\r",
							"    var skillObjectSchema = {\r",
							"        \"type\": \"object\",\r",
							"        \"required\": [\"skillId\", \"skillName\"],\r",
							"        \"properties\": {\r",
							"            \"skillId\": { \"type\": \"integer\" },\r",
							"            \"skillName\": { \"type\": [\"string\", \"null\"] },\r",
							"            \"creationTime\": { \"type\": [\"string\", \"null\"] },\r",
							"            \"lastModTime\": { \"type\": [\"string\", \"null\"] }\r",
							"        }\r",
							"    };\r",
							"\r",
							"    var listSchema = {\r",
							"        \"type\": \"array\",\r",
							"        \"items\": skillObjectSchema\r",
							"    };\r",
							"\r",
							"    var messageSchema = {\r",
							"        \"type\": \"object\",\r",
							"        \"properties\": {\r",
							"            \"message\": { \"type\": \"string\" },\r",
							"            \"success\": { \"type\": \"boolean\" }\r",
							"        }\r",
							"    };\r",
							"\r",
							"    // --- LOGIC ---\r",
							"    if (requestName === \"Get All Skill Master\" || requestName === \"Get Skill By Skill Name\") {\r",
							"        if (pm.response.code === 200) {\r",
							"             pm.response.to.have.jsonSchema(listSchema);\r",
							"        } else {\r",
							"             pm.response.to.have.jsonSchema(messageSchema);\r",
							"        }\r",
							"    }\r",
							"    else {\r",
							"        if ((pm.response.code === 200 || pm.response.code === 201) && jsonData.skillId !== undefined) {\r",
							"            pm.response.to.have.jsonSchema(skillObjectSchema);\r",
							"        } \r",
							"        else {\r",
							"            pm.response.to.have.jsonSchema(messageSchema);\r",
							"        }\r",
							"    }\r",
							"});\r",
							""
						]
					}
				}
			]
		}
	],
	"auth": {
		"type": "bearer",
		"bearer": {
			"token": "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNkBnbWFpbC5jb20iLCJpYXQiOjE3NjQ1NTY5MjMsImV4cCI6MTc2NDU4NTcyM30.oTY9hyJFcapXSIkovhNbOdsgH_lbKSJ4lvghmEohoeKNKY0L0DI-A3P1GEry4gALGjNg8p4MEVMe6BA6rN6k5g"
		}
	},
	"variable": [
		{
			"id": "848b4479-bea0-4245-a473-3dcd00801bda",
			"key": "token",
			"value": "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJ0ZWFtNkBnbWFpbC5jb20iLCJpYXQiOjE3NjQ1NTY5MjMsImV4cCI6MTc2NDU4NTcyM30.oTY9hyJFcapXSIkovhNbOdsgH_lbKSJ4lvghmEohoeKNKY0L0DI-A3P1GEry4gALGjNg8p4MEVMe6BA6rN6k5g"
		},
		{
			"id": "f2308e01-3760-4e70-9d9e-8e668ec6bd02",
			"key": "userId",
			"value": "U601"
		},
		{
			"id": "d90663da-5969-4b92-a3d5-ec89a3f8ad20",
			"key": "batchId",
			"value": "1"
		},
		{
			"id": "0aedccb5-9ff8-41eb-a3e5-cefd292bad03",
			"key": "roleId",
			"value": "R01"
		},
		{
			"id": "a10da4d3-e995-422e-829f-83c78f0671df",
			"key": "programId",
			"value": "01"
		},
		{
			"id": "302e3232-1a84-40dd-aaca-50e9aaf4334d",
			"key": "baseUrl",
			"value": "https://lms-hackathon-nov-2025-8dd40899c026.herokuapp.com/lms"
		},
		{
			"id": "302e3232-1a84-40dd-aaca-50e9aaf40000",
			"key": "skillMasterName",
			"value": "SIEM"
		},
		{
			"id": "302e3232-1a84-40dd-aaca-50e9aaf41111",
			"key": "skillId",
			"value": "1020"
		},
		{
			"id": "1b26fc93-5e57-4834-a259-0c516debfcaa",
			"key": "batchName",
			"value": ""
		},
		{
			"id": "abcbf7ca-5847-4857-ab1c-5702e3d42235",
			"key": "programName",
			"value": ""
		},
		{
			"id": "33ff8c18-ab1a-4ba1-8126-3b121d2064d2",
			"key": "programDescription",
			"value": ""
		},
		{
			"id": "8b7e3ab1-4346-41d4-9130-87c69fc2bc98",
			"key": "DeleteByPgmIdRespCd",
			"value": ""
		},
		{
			"id": "aa6e5838-8b69-4da7-9c35-b1971e0a0e73",
			"key": "DeleteByPgmIdExecuted",
			"value": ""
		},
		{
			"id": "fc77083d-0df1-4f30-99c4-88d82f858cb6",
			"key": "GetProgramDlteByIdExecuted",
			"value": ""
		},
		{
			"id": "d2df1336-749a-4eee-988a-740b2eb936bc",
			"key": "DeleteByPgmNmeRespCd",
			"value": ""
		},
		{
			"id": "0fb7dbf2-e741-46f2-ad6e-a305a45e3c03",
			"key": "DeleteByPgmNmeExecuted",
			"value": ""
		}
	]
}